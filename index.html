<!DOCTYPE html>
<html>

<head>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>
  <style>
    .area {
      stroke: royalblue;
      fill: skyblue;
      stroke-width: 2px;
    }
  </style>
</head>

<body>
  <h1>Hate Crimes in NYC</h1>
  <p>By: Gracie Jing (kgj7), Connie Liu (cl2264), Olivia Zhu (oz28)</p>

  <div id="filters"></div>
  <div id="details">
    <h4>Details:</h4>
  </div>
  <button id="demographic">Show Demographic Overlay</button>
  <div id="legend"></div>
  <svg id="colorLegend" height="100" width="600" style="background: #fff; margin-top: 30px"></svg>
  <svg id="map" width="400" height="300"></svg>
  <svg id="bar" width="1400" height="400"></svg>
  <svg id="linegraph" width="1000" height="800"></svg>

  <script>
    //create cloropleth
    const svg = d3.select("svg#map");
    const linegraph = d3.select("svg#linegraph");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 20, right: 20, bottom: 20, left: 20 };

    //precinct map
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;
    const map = svg
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    //demographic map
    const demoMap = svg
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    const outlines = svg
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // create linegraph
    const linewidth = linegraph.attr("width");
    const lineheight = linegraph.attr("height");
    const linemargin = { top: 10, right: 10, bottom: 50, left: 50 };
    const line_chartWidth = linewidth - linemargin.left - linemargin.right;
    const line_chartHeight = lineheight - linemargin.top - linemargin.bottom;

    const requestData = async function () {
      // a CSV dataset of NYPD hate crimes
      let hateCrimes = await d3.csv("NYPD_Hate_Crimes2.csv", d3.autoType);

      // a GeoJSON dataset of police precincts in NYC
      let precincts = await d3.json("Police_Precincts.geojson");
      // console.log(precincts)

      let communities = await d3.json("Community Districts.geojson");

      // a CSV dataset of demographics of NYC
      let demographics = await d3.csv("demo_2018_acs5yr_puma.csv");

      const boroughToNum = {
        Queens: "4",
        Bronx: "2",
        Manhattan: "1",
        Brooklyn: "3",
        "Staten Island": "5",
      };

      // clean up hate crime data
      // create d3 time objects
      let timeParser = d3.timeParse("%m/%d/%Y");

      let min_date = timeParser(hateCrimes[0]["Record Create Date"]);
      let max_date = min_date;

      hateCrimes.forEach((d) => {
        d["Arrest Date"] = timeParser(d["Arrest Date"]);
        d["Record Create Date"] = timeParser(d["Record Create Date"]);

        // find the min and max date for the time slider
        if (d["Record Create Date"] < min_date) {
          min_date = d["Record Create Date"];
        } else if (d["Record Create Date"] > max_date) {
          max_date = d["Record Create Date"];
        }

        d["precinct"] = d["Complaint Precinct Code"];
      });

      // clean up demographic data
      demographics.pop();
      demographics.forEach((d) => {
        d.asian = Number(d["AsnNHE"].replace(/,/g, ""));
        d.hispanic = Number(d["Hsp1E"].replace(/,/g, ""));
        d.white = Number(d["WtNHE"].replace(/,/g, ""));
        d.native = Number(d["AIANNHE"].replace(/,/g, ""));
        d.black = Number(d["BlNHE"].replace(/,/g, ""));
        d.hawaiianpi = Number(d["NHPINHE"].replace(/,/g, ""));
        d.other = Number(d["OthNHE"].replace(/,/g, ""));
        d.twoplus = Number(d["Rc2plNHE"].replace(/,/g, ""));
        d.boro_cd = getCDNum(d["GeogName"], d["Borough"]); //PUMAtoBoroCD[d['GeogName'].replace(/; New York/, "").replace(/, New York/, "")]
      });

      console.log(hateCrimes);
      console.log(precincts);
      console.log(demographics);
      console.log(communities);

      let colorScale = d3.scaleQuantile();

      //create map for precincts
      var precinctProjection = d3
        .geoMercator()
        .fitSize([mapWidth, mapHeight], precincts);
      var precinctPath = d3.geoPath().projection(precinctProjection);
      map
        .selectAll("path.precinct")
        .data(precincts.features)
        .join("path")
        .attr("class", (d) => `precinct p${d.properties.precinct}`)
        .attr("d", precinctPath);

      //outline
      outlines
        .selectAll("path.outline")
        .data(precincts.features)
        .join("path")
        .attr("class", (d) => `precinct outline p${d.properties.precinct}`)
        .attr("fill-opacity", 0)
        .attr("stroke", "black")
        .attr("stroke-width", 1)
        .attr("d", precinctPath)
        .on("click", updateSelected);

      // .append("path")
      // .attr("d", precinctPath)
      // .attr("class", "activeRegion")

      //create demographic overlay
      let races = [
        "asian",
        "black",
        "hispanic",
        "white",
        "native",
        "hawaiianpi",
        "other",
        "twoplus",
        null,
      ];
      let demoScale = d3
        .scaleOrdinal()
        .domain(races)
        .range(d3.schemeCategory10);

      var demoProjection = d3
        .geoMercator()
        .fitSize([mapWidth, mapHeight], communities);
      var demoPath = d3.geoPath().projection(demoProjection);
      demoMap
        .selectAll("path.community")
        .data(communities.features)
        .join("path")
        .attr("class", "community") //d =>`zipcode z${d.properties.precinct}`)
        .attr("stroke", "black")
        .attr("stroke-width", 1)
        .attr("d", demoPath)
        .attr("opacity", 0.5)
        .attr("fill", (d) => demoScale(getDomDemo(d)))
        .attr("visibility", "hidden");

      //create button to show demographic overlay
      let showDemoButton = d3.select("button#demographic");
      showDemoButton.attr("clicked", false).on("click", showDemographics);

      //create filters for hate crime types
      var hateCrimeTypes = [];
      hateCrimes.forEach((row, i) => {
        let type = row["Bias Motive Description"];
        if (!hateCrimeTypes.includes(type)) {
          hateCrimeTypes.push(type);
        }
      });
      hateCrimeTypes.sort();
      console.log(hateCrimeTypes);
      // hateCrimeTypes.pop(null);

      // create filters
      let filters = d3.select("#filters");
      let crimeFilter = filters
        .append("div")
        .attr("id", "type")
        .attr("class", "filter");

      let updateButton = filters
        .append("button")
        .attr("id", "update")
        .text("Update")
        .on("click", updateFiltered);

      let clearButton = filters
        .append("button")
        .attr("id", "clear")
        .text("Clear")
        .on("click", clearFilters);

      hateCrimeTypes.forEach((d) => {
        crimeFilter
          .append("input")
          .attr("name", d)
          .attr("type", "checkbox")
          .attr("class", "type")
          .attr("param", "Bias Motive Description");

        crimeFilter.append("label").attr("for", d).text(d);
      });


      let timeSliderHeight = 300;
      let timeSliderWidth = 1000;

      let values = hateCrimes.map(d => d["Record Create Date"]);

      let formatTime = d3.timeFormat("%B %d, %Y");

      let xScale = d3.scaleLinear().domain([min_date, max_date]).range([10, timeSliderWidth - 10]);
      let xAxis = d3.axisBottom(xScale).tickFormat(formatTime);

      let wrapper = filters.append("div").attr("class", "control");
      wrapper.append("div").text("Time Scale: ");
      let canvas = wrapper.append("svg").attr("width", timeSliderWidth)
        .attr("height", timeSliderHeight + 50);

      let areaLayer = canvas.append("g").attr("class", "areaLayer");
      canvas.append("g")
        .attr("transform", `translate(0, ${timeSliderHeight + 10})`)
        .attr('class', "x-axis")
        .call(xAxis);

      let numBins = 20;
      let histoGen = d3.histogram().domain([min_date, max_date])
        .thresholds(numBins);

      let counts = histoGen(values);

      let time_spacing = counts[1].x1 - counts[1].x0;

      counts[0].x0 = counts[0].x1 - time_spacing;
      counts[counts.length - 1].x1 = counts[counts.length - 1].x0 + time_spacing;

      counts.unshift({
        x0: 0,
        x1: counts[0].x0,
        length: counts[0].length
      });

      console.log("counts");
      console.log(counts);

      let yScale = d3.scaleLinear()
        .domain(d3.extent(counts, d => d.length))
        .range([timeSliderHeight, 4]);

      let area = d3.area().x(d => xScale(d.x1))
        .y0(yScale(0) + 10)
        .y1(d => yScale(d.length))
        .curve(d3.curveNatural);

      areaLayer.append("path").datum(counts)
        // .attr("transform", `translate(0, -50)`)
        .attr("class", "area")
        .attr("d", area);

      let brush = d3.brushX().extent([[10, 0], [timeSliderWidth - 10, timeSliderHeight]])
        .on("brush end", brushMoved);

      let filterFunc = d => true;
      function brushMoved(event) {
        // console.log(event.type, event.selection, event);

        if (event.selection !== null) {
          let startPixels = event.selection[0];
          let start = xScale.invert(startPixels);

          let endPixels = event.selection[1];
          let end = xScale.invert(endPixels);

          filterFunc = d => d["Record Create Date"] >= start && d["Record Create Date"] <= end;
        } else {
          filterFunc = d => true;
        }
        updateHateCrimeData(filterFunc, hateCrimes);
      }

      function updateHateCrimeData(filterFunc, hateCrimes) {
        let filteredHateCrimes = hateCrimes.filter(d => filterFunc(d));

        console.log(filteredHateCrimes);
      }

      canvas.append("g").attr("class", "brush").call(brush);

      //creating legends
      let demoLegend = d3
        .select("#legend")
        .append("g")
        .attr("id", "demoLegend");
      races.forEach((r) => {
        demoLegend.append("span").text(r).style("color", demoScale(r));
      });
      demoLegend
        .append("span")
        .text("no demographic data")
        .style("color", demoScale(null));

      let colorLegend = d3.select("#colorLegend");
      colorLegend.append("g").attr("class", "colorbar axis");
      // drawLegend(colorLegend, colorScale)

      //adding details for precinct on click
      let details = d3
        .select("#details")
        .append("text")
        .attr("id", "precinct")
        .attr("x", 0)
        .attr("y", 0)
        .attr("fill", "black")
        .text("No selected precincts");

      // let clickmesh = map.append("path").attr("class", "mouseover outline").attr("d", "");

      let filteredHateCrimes = hateCrimes;
      let selectedPrecincts = [];
      let selectedHateCrimes = hateCrimes;

      //line graph scales
      // const crimeExtent = d3.extent(data, (d) => d["precinctstuff"]);
      // const crimeScale = d3
      //   .scaleLinear()
      //   .domain(crimeExtent)
      //   .range([line_chartHeight, 0]);
      //
      // const dateExtent = d3.extent(data, (d) => d["date"]);
      // const dateScale = d3
      //   .scaleTime()
      //   .domain(dateExtent)
      //   .range([0, chartWidth]);
      // // Y axis
      // let leftAxis = d3.axisLeft(crimeScale);
      // let leftGridlines = d3
      //   .axisLeft(crimeScale)
      //   .tickSize(-chartWidth - 10)
      //   .tickFormat("");
      // annotations
      //   .append("g")
      //   .attr("class", "y axis")
      //   .attr(
      //     "transform",
      //     `translate(${linemargin.left - 10},${linemargin.top})`
      //   )
      //   .call(leftAxis);
      // annotations
      //   .append("g")
      //   .attr("class", "y gridlines")
      //   .attr(
      //     "transform",
      //     `translate(${linemargin.left - 10},${linemargin.top})`
      //   )
      //   .call(leftGridlines);
      // // X axis
      // let bottomAxis = d3.axisBottom(dateScale);
      // let bottomGridlines = d3
      //   .axisBottom(dateScale)
      //   .tickSize(-line_chartHeight - 10)
      //   .tickFormat("");
      // annotations
      //   .append("g")
      //   .attr("class", "x axis")
      //   .attr(
      //     "transform",
      //     `translate(${linemargin.left},${
      //       line_chartHeight + linemargin.top + 10
      //     })`
      //   )
      //   .call(bottomAxis);
      // annotations
      //   .append("g")
      //   .attr("class", "x gridlines")
      //   .attr(
      //     "transform",
      //     `translate(${linemargin.left},${
      //       line_chartHeight + linemargin.top + 10
      //     })`
      //   )
      //   .call(bottomGridlines);
      // var lineGen = d3
      //   .line()
      //   .x((d) => dateScale(d["date"]))
      //   .y((d) => crimeScale(d["frequncy of crimes"]))
      //   .curve(d3.curveMonotoneX); // this configures whether straight lines connect your data points
      // //  or if it blends between points using a curve; see d3.line docs
      // //final graph
      // chartArea
      //   .append("path")
      //   .datum(data)
      //   .attr("class", "line")
      //   .attr("fill", "none")
      //   .attr("stroke", "steelblue")
      //   .attr("stroke-width", 3)
      //   .attr("d", lineGen);

      function getCDNum(s, boro) {
        i1 = s.indexOf("District") + 9;
        i2 = s.indexOf("--");
        cds = s.slice(i1, i2).split(" & ");
        cds.forEach((item, i) => {
          if (item.length < 2) {
            item = "0" + item;
          }
          cds[i] = boroughToNum[boro] + item;
        });

        return cds;
      }

      function updateSelected() {
        let precinct = d3.select(this);
        let precinctNumber = precinct.datum().properties["precinct"];

        let txt = d3.select("text#precinct");

        // already selected
        if (selectedPrecincts.includes(precinctNumber)) {
          d3.selectAll(`.outline.p${precinctNumber}`).each(function () {
            d3.select(this).attr("stroke-width", 1);
          });
          selectedPrecincts = selectedPrecincts.filter(
            (d) => d !== precinctNumber
          );
          if (selectedPrecincts === []) {
            txt.text("No selected precincts");
          } else {
            txt.text(`Selected Precincts: ${selectedPrecincts}`);
          }
        } else {
          // console.log(d3.selectAll(`.outline.p${precinctNumber}`))
          d3.selectAll(`.outline.p${precinctNumber}`).each(function () {
            // console.log(d3.select(this))
            d3.select(this).attr("stroke-width", 3);
            // console.log(d3.select(this))
          });

          selectedPrecincts.push(precinctNumber);
          txt.text(`Selected Precincts: ${selectedPrecincts}`);
        }

        // updateFiltered();
        // updatePrecincts();

        // updatePrecincts();
      }

      function showDemographics() {
        if (showDemoButton.attr("clicked") === "true") {
          showDemoButton.text("Show Demographic Overlay");
          demoMap.selectAll("path.community").attr("visibility", "hidden");
          showDemoButton.attr("clicked", false);
        } else {
          showDemoButton.text("Remove Demographic Overlay");
          demoMap
            .selectAll("path.community")
            .attr("visibility", "")
            .attr("stroke-width", 0);
          d3.selectAll(".outline").each(function () {
            console.log(d3.select(this));
            d3.select(this).raise();
          });
          // console.log(precinctAreas.selectAll(".outline"))
          showDemoButton.attr("clicked", true);
        }

        // map.selectAll("path.precinct")
        //    .attr("stroke-width", 0)
      }

      function clearFilters() {
        filters.selectAll(".type").each(function () {
          d3.select(this).property("checked", false);
        });

        selectedPrecincts.forEach((precinctNumber) => {
          d3.selectAll(`.outline.p${precinctNumber}`).each(function () {
            d3.select(this).attr("stroke-width", "1");
          });
        });
        selectedPrecincts = [];

        filteredHateCrimes = hateCrimes;
        updatePrecincts();
      }

      //update precincts based on filtered data
      function updateFiltered() {
        let checkedFilters = [];
        //get filtered data
        filters.selectAll(".type").each(function () {
          let filter = d3.select(this);
          let checked = filter.property("checked");
          if (checked) {
            checkedFilters.push(filter);
          }
        });

        if (checkedFilters.length === 0) {
          filteredHateCrimes = hateCrimes;
        } else {
          filteredHateCrimes = hateCrimes.filter((d) => {
            let include = false;

            //check satisfies hate crime type filters
            checkedFilters.forEach((fil) => {
              // console.log(fil);
              let key = fil.attr("param");
              let val = fil.attr("name");
              if (d[key] === val) {
                include = true;
              }
            });

            return include;
          });
        }

        console.log(filteredHateCrimes);

        updatePrecincts();
      }

      function updatePrecincts() {
        //initialize hate crime frequency dictionary
        let precinctCrimeCount = {};

        // updateFiltered();
        precincts.features.forEach((d) => {
          precinctCrimeCount[d.properties.precinct] = 0;
        });
        //tabulates hatecrimes
        filteredHateCrimes.forEach((d) => {
          precinctCrimeCount[d.precinct] += 1;
        });

        //need to figure out colorScale
        //update color scale
        colorScale
          .domain(Object.values(precinctCrimeCount))
          .range(d3.schemeGreys[5]);

        //color precincts
        map.selectAll(".precinct").style("fill", (d) => {
          count = precinctCrimeCount[d.properties.precinct];
          if (count === 0) {
            return colorScale.range()[0];
          } else {
            return colorScale(count);
          }
        });

        //update legend
        drawLegend(colorLegend, colorScale);
        //put code updating here, assume dataset is filteredhatecrimes
        displayBar();
      }

      //creates a new dataset of only stuff from that precinct
      //use filterdhatecrimes+ hatecrimetypes
      //white {type: white number: 20}, black {type: white number: 20}
      function wrap(text, width) {
        text.each(function () {
          var text = d3.select(this),
            words = text.text().split(/\s+/).reverse(),
            word,
            line = [],
            lineNumber = 0,
            lineHeight = 1.1, // ems
            y = text.attr("y"),
            dy = parseFloat(text.attr("dy")),
            tspan = text
              .text(null)
              .append("tspan")
              .attr("x", 0)
              .attr("y", y)
              .attr("dy", dy + "em");
          while ((word = words.pop())) {
            line.push(word);
            tspan.text(line.join(" "));
            if (tspan.node().getComputedTextLength() > width) {
              line.pop();
              tspan.text(line.join(" "));
              line = [word];
              tspan = text
                .append("tspan")
                .attr("x", 0)
                .attr("y", y)
                .attr("dy", ++lineNumber * lineHeight + dy + "em")
                .text(word);
            }
          }
        });
      }
      function displayBar() {
        // console.log("hi");
        hateCrimeCount = {};

        hateCrimeTypes.forEach((r) => {
          hateCrimeCount[r] = { type: r, number: 0 };
        });
        // console.log(hateCrimeCount);

        filteredHateCrimes.forEach((d) => {
          // console.log(d["Bias Motive Description"]);
          // console.log(hateCrimeCount[d["Bias Motive Description"]]);
          hateCrimeCount[d["Bias Motive Description"]]["number"] += 1;
        });
        console.log(hateCrimeCount["number"]);
        var hateCountList = Object.values(hateCrimeCount);
        var dictLength = Object.values(hateCrimeCount).length;
        console.log(hateCountList);
        let bar = d3.select("svg#bar");
        var margin = { top: 30, right: 30, bottom: 90, left: 70 };
        let width = bar.attr("width");
        let height = bar.attr("height");
        const chartWidth = width - margin.left - margin.right;
        const chartHeight = height - margin.top - margin.bottom;
        let annotations = bar.append("g").attr("id", "annotations1");
        var chartArea = bar
          .append("g")
          .attr("id", "points")
          .attr(
            "transform",
            "translate(" + margin.left + "," + margin.top + ")"
          );
        var xScale = d3
          .scaleBand()
          .domain(hateCrimeTypes)
          .range([0, chartWidth])
          .padding([0.2]);
        bar
          .append("g")
          .attr(
            "transform",
            "translate(" +
            margin.left +
            "," +
            (chartHeight + margin.top) +
            ")"
          )
          .call(d3.axisBottom(xScale).tickSizeOuter(0));
        const totalExtent = d3.extent(hateCountList, (d) => d["number"]);
        // console.log(hateCrimeCount["number"]);
        // console.log(totalExtent);
        var yScale = d3
          .scaleLinear()
          .domain([0, totalExtent[1]])
          .range([chartHeight, 0]);
        let leftAxis = d3.axisLeft(yScale);
        let leftGridlines = d3
          .axisLeft(yScale)
          .tickSize(-chartWidth - 10)
          .tickFormat("");
        annotations
          .append("g")
          .attr("class", "y axis")
          .attr(
            "transform",
            "translate(" + (margin.left - 10) + "," + margin.top + ")"
          )
          .call(leftAxis);
        annotations
          .append("g")
          .attr("class", "y gridlines")
          .attr(
            "transform",
            "translate(" + (margin.left - 10) + "," + margin.top + ")"
          )
          .call(leftGridlines);
        var colorScale = d3
          .scaleOrdinal(d3.schemeCategory10)
          .domain(hateCrimeTypes);
        chartArea
          .selectAll("rect.bar")
          .data(hateCountList)
          .join("rect")
          .attr("class", "bar")
          .attr("fill", "steelblue")
          .attr("x", (d) => xScale(d["type"]))
          .attr("y", (d) => yScale(d["number"]))
          .attr("height", (d) => yScale(0) - yScale(d["number"]))
          .attr("width", xScale.bandwidth());
      }
      function getDomDemo(d) {
        n = demographics.filter((demo) => {
          return demo.boro_cd.includes(d.properties["boro_cd"]);
        });
        if (n.length === 0) {
          return null;
        }
        maxPop = 0;
        domPop = null;
        races.forEach((r) => {
          if (n[0][r] > maxPop) {
            maxPop = n[0][r];
            domPop = r;
          }
        });
        return domPop;
      }
      //get top three values
      function getTopThree(d) {
        console.log(selectedPrecincts);
        console.log(demographics);
        n = demographics.filter((demo) => {
          return demo.boro_cd.includes(
            (d.properties["boro_cd"] = selectedPrecincts)
          );
        });
        if (n.length === 0) {
          return null;
        }
        // console.log(d);
        // console.log(n);
        pop1 = 0;
        pop2 = 0;
        pop3 = 0;
        firstpop = null;
        secondpop = null;
        thirdpop = null;

        topThree = [];
        races.forEach((r) => {
          if (n[0][r] > pop1) {
            pop3 = pop2;
            pop2 = pop1;
            pop1 = n[0][r];
            firstpop = r;
          } else if (n[0][r] > pop2) {
            pop3 = pop2;
            pop2 = n[0][r];
            secondpop = r;
          } else if (n[0][r] > pop3) {
            pop3 = n[0][r];
            thirdpop = r;
          }
        });
        topThree.push(pop1);
        topThree.push(pop2);
        topThree.push(pop3);
        return topThree;
      }

      updatePrecincts();
    };

    requestData();

    // MODIFIED CODE FROM 3/22 LECTURE TO DRAW LEGEND
    // Function needs a d3 selected SVG canvas where it will draw the legend and a source color scale
    function drawLegend(legend, legendColorScale) {
      // Bonus code here to draw an adaptive gradient legend so we can see different color scales for choropleth maps
      //  Credit Prof. Rz if you are basing a legend on this structure, and note SERIOUS PERFORMANCE CONSIDERATIONS

      //const legend = d3.select("#colorLegend");
      const legendWidth = legend.attr("width");
      const legendHeight = legend.attr("height");
      const legendMinMax = d3.extent(legendColorScale.domain()); // way to recover the minMax from most kinds of scales
      const barHeight = 60;
      const stepSize = 4; // warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance
      // Extend the minmax by 1 in either direction to expose more features
      const pixelScale = d3
        .scaleLinear()
        .domain([0, legendWidth - 40])
        .range([legendMinMax[0] - 1, legendMinMax[1] + 1]); // In this case the "data" are pixels, and we get numbers to use in colorScale
      const barScale = d3
        .scaleLinear()
        .domain([legendMinMax[0] - 1, legendMinMax[1] + 1])
        .range([0, legendWidth - 40]);
      const barAxis = d3.axisBottom(barScale);
      // Check if we're using a quantile scale - if so, we can do better
      if (legendColorScale.hasOwnProperty("quantiles")) {
        // Use the quantile breakpoints plus the min and max of the scale as tick values
        barAxis.tickValues(legendColorScale.quantiles().concat(legendMinMax));
      }
      legend
        .select(".colorbar, .axis")
        .attr("transform", "translate(" + 20 + "," + (barHeight + 5) + ")")
        .call(barAxis);
      // .call(barAxis);

      // Draw rects of color down the bar
      let bar = legend
        .append("g")
        .attr("transform", "translate(" + 20 + "," + 0 + ")");
      for (let i = 0; i < legendWidth - 40; i = i + stepSize) {
        bar
          .append("rect")
          .attr("x", i)
          .attr("y", 0)
          .attr("width", stepSize)
          .attr("height", barHeight)
          .style("fill", legendColorScale(pixelScale(i))); // pixels => countData => color
      }
      // Put lines in to mark actual min and max of our data
      bar
        .append("line")
        .attr("stroke", "white")
        .attr("stroke-width", 3)
        .attr("x1", barScale(legendMinMax[0]))
        .attr("x2", barScale(legendMinMax[0]))
        .attr("y1", 0)
        .attr("y1", barHeight + 4);
      bar
        .append("line")
        .attr("stroke", "white")
        .attr("stroke-width", 3)
        .attr("x1", barScale(legendMinMax[1]))
        .attr("x2", barScale(legendMinMax[1]))
        .attr("y1", 0)
        .attr("y1", barHeight + 4);
    }

    //function to update the legend
    function updateLegend(legend, legendColorScale) {
      const barAxis = d3.axisBottom(barScale);
      // Check if we're using a quantile scale - if so, we can do better
      if (legendColorScale.hasOwnProperty("quantiles")) {
        // Use the quantile breakpoints plus the min and max of the scale as tick values
        barAxis.tickValues(legendColorScale.quantiles().concat(legendMinMax));
      }
      legend.select(".colorbar, .axis").call(barAxis);
    }
  </script>
</body>

</html>