<!DOCTYPE html>
<html>
  <head>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <style>
    </style>
  </head>

  <body>
    <h1>Hate Crimes in NYC</h1>
    <p>By: Gracie Jing (kgj7), Connie Liu (cl2264), Olivia Zhu (oz28)</p>

    <div id="filters"></div>
    <div id="details">
      <h4>Details:</h4>
    </div>
    <button id="demographic">Show Demographic Overlay</button>
    <div id="legend"></div>
    <svg id="colorLegend" height="100" width="600" style="background: #fff; margin-top:30px"></svg>
    <svg id="map" width="1000" height="800"></svg>
    <svg id="linegraph" width="1000" height="800"></svg>
    <svg id="bar" width="1000" height="800"></svg>
    <script>
      //create cloropleth
      const svg = d3.select("svg#map");
      const linegraph = d3.select("svg#linegraph");
      const width = svg.attr("width");
      const height = svg.attr("height");
      const margin = { top: 20, right: 20, bottom: 20, left: 20 };

      //precinct map
      const mapWidth = width - margin.left - margin.right;
      const mapHeight = height - margin.top - margin.bottom;
      const map = svg
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      //demographic map
      const demoMap = svg
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      const outlines = svg.append("g")
                          .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      // create linegraph
      const linewidth = linegraph.attr("width");
      const lineheight = linegraph.attr("height");
      const linemargin = { top: 10, right: 10, bottom: 50, left: 50 };
      const line_chartWidth = linewidth - linemargin.left - linemargin.right;
      const line_chartHeight = lineheight - linemargin.top - linemargin.bottom;


      const requestData = async function () {
        // a CSV dataset of NYPD hate crimes
        let hateCrimes = await d3.csv("NYPD_Hate_Crimes2.csv", d3.autoType);

        // a GeoJSON dataset of police precincts in NYC
        let precincts = await d3.json("Police_Precincts.geojson");
        // console.log(precincts)

        let communities= await d3.json("Community Districts.geojson");

        // a CSV dataset of demographics of NYC
        let demographics = await d3.csv("demo_2018_acs5yr_puma.csv");

        const boroughToNum = {
          Queens: "4",
          Bronx: "2",
          Manhattan: "1",
          Brooklyn: "3",
          "Staten Island": "5",
        };

        // clean up hate crime data
        // create d3 time objects
        let timeParser = d3.timeParse("%m/%d/%Y");

        hateCrimes.forEach((d) => {
          d["Arrest Date"] = timeParser(d["Arrest Date"]);
          d["Record Create Date"] = timeParser(d["Record Create Date"]);
          d["precinct"] = d["Complaint Precinct Code"];
        });

        // clean up demographic data
        demographics.pop();
        demographics.forEach((d) => {
          d.asian = Number(d["AsnNHE"].replace(/,/g, ""));
          d.hispanic = Number(d["Hsp1E"].replace(/,/g, ""));
          d.white = Number(d["WtNHE"].replace(/,/g, ""));
          d.native = Number(d["AIANNHE"].replace(/,/g, ""));
          d.black = Number(d["BlNHE"].replace(/,/g, ""));
          d.hawaiianpi = Number(d["NHPINHE"].replace(/,/g, ""));
          d.other = Number(d["OthNHE"].replace(/,/g, ""));
          d.twoplus = Number(d["Rc2plNHE"].replace(/,/g, ""));
          d.boro_cd = getCDNum(d["GeogName"], d["Borough"]); //PUMAtoBoroCD[d['GeogName'].replace(/; New York/, "").replace(/, New York/, "")]
        })

        console.log(hateCrimes);
        console.log(precincts);
        console.log(demographics);
        console.log(communities);

        let colorScale = d3.scaleQuantile()

        //create map for precincts
        var precinctProjection = d3.geoMercator().fitSize([mapWidth, mapHeight], precincts);
        var precinctPath = d3.geoPath().projection(precinctProjection);
        map.selectAll("path.precinct")
           .data(precincts.features)
           .join("path")
           .attr("class", d =>`precinct p${d.properties.precinct}`)
           .attr("d", precinctPath);

        //outline
        outlines.selectAll("path.outline")
           .data(precincts.features)
           .join("path")
           .attr("class", d =>`precinct outline p${d.properties.precinct}`)
           .attr("fill-opacity", 0)
           .attr("stroke", "black")
           .attr("stroke-width", 1)
           .attr("d", precinctPath)
           .on("click", updateSelected);

           // .append("path")
           // .attr("d", precinctPath)
           // .attr("class", "activeRegion")


        //create demographic overlay
        let races = ['asian','black','hispanic','white','native','hawaiianpi', 'other', 'twoplus', null];
        let demoScale = d3.scaleOrdinal()
                          .domain(races)
                          .range(d3.schemeCategory10);

        var demoProjection = d3.geoMercator().fitSize([mapWidth, mapHeight], communities);
        var demoPath = d3.geoPath().projection(demoProjection);
        demoMap.selectAll("path.community")
               .data(communities.features)
               .join("path")
               .attr("class", "community") //d =>`zipcode z${d.properties.precinct}`)
               .attr("stroke", "black")
               .attr("stroke-width", 1)
               .attr("d", demoPath)
               .attr("opacity", 0.5)
               .attr("fill", (d) => demoScale(getDomDemo(d)))
               .attr("visibility", "hidden");

        //create button to show demographic overlay
        let showDemoButton = d3.select("button#demographic");
        showDemoButton.attr("clicked", false).on("click", showDemographics);

        //create filters for hate crime types
        var hateCrimeTypes = [];
        hateCrimes.forEach((row, i) => {
          let type = row["Bias Motive Description"];
          if (!hateCrimeTypes.includes(type)) {
            hateCrimeTypes.push(type);
          }
        });
        hateCrimeTypes.sort();
        hateCrimeTypes.pop(null);

        // create filters
        let filters = d3.select("#filters");
        let crimeFilter = filters.append("div")
                                 .attr("id", "type")
                                 .attr("class", "filter");

        let updateButton = filters.append("button")
                                  .attr("id", "update")
                                  .text("Update")
                                  .on("click", updateFiltered);

        let clearButton = filters.append("button")
                                 .attr("id", "clear")
                                 .text("Clear")
                                 .on("click", clearFilters);

        hateCrimeTypes.forEach((d) => {
          crimeFilter.append("input")
                     .attr("name", d)
                     .attr("type", "checkbox")
                     .attr("class", "type")
                     .attr("param", "Bias Motive Description");

          crimeFilter.append("label").attr("for", d).text(d);
        });

        //creating legends
        let demoLegend = d3.select("#legend").append("g").attr("id", "demoLegend")
        races.forEach(r => {
            demoLegend.append("span")
                      .text(r)
                      .style("color", demoScale(r))
        });
        demoLegend.append("span").text("no demographic data").style("color", demoScale(null));

        let colorLegend = d3.select("#colorLegend")
        colorLegend.append("g")
          .attr("class", "colorbar axis")
        // drawLegend(colorLegend, colorScale)

        //adding details for precinct on click
        let details = d3.select("#details")
                        .append("text")
                        .attr("id", "precinct")
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("fill", "black")
                        .text("No selected precincts");

        // let clickmesh = map.append("path").attr("class", "mouseover outline").attr("d", "");

        let filteredHateCrimes = hateCrimes;
        let selectedPrecincts = [];
        let selectedHateCrimes = hateCrimes;



        //line graph scales
        // const crimeExtent = d3.extent(data, (d) => d["precinctstuff"]);
        // const crimeScale = d3
        //   .scaleLinear()
        //   .domain(crimeExtent)
        //   .range([line_chartHeight, 0]);
        //
        // const dateExtent = d3.extent(data, (d) => d["date"]);
        // const dateScale = d3
        //   .scaleTime()
        //   .domain(dateExtent)
        //   .range([0, chartWidth]);
        // // Y axis
        // let leftAxis = d3.axisLeft(crimeScale);
        // let leftGridlines = d3
        //   .axisLeft(crimeScale)
        //   .tickSize(-chartWidth - 10)
        //   .tickFormat("");
        // annotations
        //   .append("g")
        //   .attr("class", "y axis")
        //   .attr(
        //     "transform",
        //     `translate(${linemargin.left - 10},${linemargin.top})`
        //   )
        //   .call(leftAxis);
        // annotations
        //   .append("g")
        //   .attr("class", "y gridlines")
        //   .attr(
        //     "transform",
        //     `translate(${linemargin.left - 10},${linemargin.top})`
        //   )
        //   .call(leftGridlines);
        // // X axis
        // let bottomAxis = d3.axisBottom(dateScale);
        // let bottomGridlines = d3
        //   .axisBottom(dateScale)
        //   .tickSize(-line_chartHeight - 10)
        //   .tickFormat("");
        // annotations
        //   .append("g")
        //   .attr("class", "x axis")
        //   .attr(
        //     "transform",
        //     `translate(${linemargin.left},${
        //       line_chartHeight + linemargin.top + 10
        //     })`
        //   )
        //   .call(bottomAxis);
        // annotations
        //   .append("g")
        //   .attr("class", "x gridlines")
        //   .attr(
        //     "transform",
        //     `translate(${linemargin.left},${
        //       line_chartHeight + linemargin.top + 10
        //     })`
        //   )
        //   .call(bottomGridlines);
        // var lineGen = d3
        //   .line()
        //   .x((d) => dateScale(d["date"]))
        //   .y((d) => crimeScale(d["frequncy of crimes"]))
        //   .curve(d3.curveMonotoneX); // this configures whether straight lines connect your data points
        // //  or if it blends between points using a curve; see d3.line docs
        // //final graph
        // chartArea
        //   .append("path")
        //   .datum(data)
        //   .attr("class", "line")
        //   .attr("fill", "none")
        //   .attr("stroke", "steelblue")
        //   .attr("stroke-width", 3)
        //   .attr("d", lineGen);

        function getCDNum(s, boro) {
          i1 = s.indexOf("District") + 9;
          i2 = s.indexOf("--");
          cds = s.slice(i1, i2).split(" & ");
          cds.forEach((item, i) => {
            if (item.length < 2) {
              item = "0" + item;
            }
            cds[i] = boroughToNum[boro] + item;
          });

          return cds;
        }

        function updateSelected() {
          let precinct = d3.select(this);
          let precinctNumber = precinct.datum().properties["precinct"];

          let txt = d3.select("text#precinct");

          // already selected
          if (selectedPrecincts.includes(precinctNumber)) {
            d3.selectAll(`.outline.p${precinctNumber}`).each(function() {
              d3.select(this).attr("stroke-width", 1);
            });
            selectedPrecincts = selectedPrecincts.filter(
              (d) => d !== precinctNumber
            );
            if (selectedPrecincts === []) {
              txt.text("No selected precincts");
            } else {
              txt.text(`Selected Precincts: ${selectedPrecincts}`);
            }
          } else {
            // console.log(d3.selectAll(`.outline.p${precinctNumber}`))
            d3.selectAll(`.outline.p${precinctNumber}`).each(function () {
              // console.log(d3.select(this))
              d3.select(this).attr("stroke-width", 3);
              // console.log(d3.select(this))
            });

            selectedPrecincts.push(precinctNumber);
            txt.text(`Selected Precincts: ${selectedPrecincts}`);

            // displayBar(selectedPrecincts);
          }

          // updateFiltered();
          // updatePrecincts();

          // updatePrecincts();
        }

        function showDemographics() {
          if (showDemoButton.attr("clicked") === "true") {
            showDemoButton.text("Show Demographic Overlay");
            demoMap.selectAll("path.community").attr("visibility", "hidden");
            showDemoButton.attr("clicked", false);
          } else {
            showDemoButton.text("Remove Demographic Overlay");
            demoMap.selectAll("path.community")
                   .attr("visibility", "")
                   .attr("stroke-width", 0);
            d3.selectAll(".outline").each(function() {
              console.log(d3.select(this))
              d3.select(this).raise()
            });
            // console.log(precinctAreas.selectAll(".outline"))
            showDemoButton.attr("clicked", true);
          }

          // map.selectAll("path.precinct")
          //    .attr("stroke-width", 0)
        }

        function clearFilters() {
          filters.selectAll(".type").each(function () {
            d3.select(this).property("checked", false);
          });

          selectedPrecincts.forEach((precinctNumber) => {
            d3.selectAll(`.outline.p${precinctNumber}`).each(function () {
              d3.select(this).attr("stroke-width", "1");
            });
          });
          selectedPrecincts = [];

          filteredHateCrimes = hateCrimes;
          updatePrecincts();
        }

        //update precincts based on filtered data
        function updateFiltered() {
          let checkedFilters = [];
          //get filtered data
          filters.selectAll(".type").each(function () {
            let filter = d3.select(this);
            let checked = filter.property("checked");
            if (checked) {
              checkedFilters.push(filter);
            }
          });

          filteredHateCrimes = hateCrimes.filter(d => {
            let include = false;

            //check satisfies hate crime type filters
            checkedFilters.forEach((fil) => {
              // console.log(fil);
              let key = fil.attr("param");
              let val = fil.attr("name");
              if (d[key] === val) {
                include = true;
              }
            });

            return include;
          });
          console.log(filteredHateCrimes);

          updatePrecincts()
        }

        function updatePrecincts() {
          //initialize hate crime frequency dictionary
          let precinctCrimeCount = {};

          // updateFiltered();
          precincts.features.forEach((d) => {
            precinctCrimeCount[d.properties.precinct] = 0;
          });
          //tabulates hatecrimes
          filteredHateCrimes.forEach((d) => {
            precinctCrimeCount[d.precinct] += 1;
          });

          //need to figure out colorScale
          //update color scale
          colorScale.domain(Object.values(precinctCrimeCount)).range(d3.schemeGreys[5]);

          //color precincts
          map.selectAll(".precinct")
             .style("fill", d => {
               count = precinctCrimeCount[d.properties.precinct];
               if (count === 0) {
                 return colorScale.range()[0];
               }
               else {
                 return colorScale(count);
               }
             });

          //update legend
          drawLegend(colorLegend,colorScale);
          //put code updating here, assume dataset is filteredhatecrimes
          // displayBar();
        }

        //creates a new dataset of only stuff from that precinct
        function displayBar() {
          filteredHateCrimes.forEach((d) => {
            hateCrimeCount[d["Bias Motive Description"]] += 1;
          });
          console.log(hateCrimeCount);
          console.log("hi");
          let bar = d3.select("svg#bar");
          var margin = { top: 30, right: 30, bottom: 90, left: 70 };
          let width = svg.attr("width");
          let height = svg.attr("height");
          const chartWidth = width - margin.left - margin.right;
          const chartHeight = height - margin.top - margin.bottom;
          let annotations = svg.append("g").attr("id", "annotations1");
          var chartArea = svg
            .append("g")
            .attr("id", "points")
            .attr(
              "transform",
              "translate(" + margin.left + "," + margin.top + ")"
            );
          var x = d3
            .scaleBand()
            .domain(hateCrimeTypes)
            .range([0, chartWidth])
            .padding([0.2]);
          svg
            .append("g")
            .attr(
              "transform",
              "translate(" +
                margin.left +
                "," +
                (chartHeight + margin.top) +
                ")"
            )
            .call(d3.axisBottom(x).tickSizeOuter(0));
          const totalExtent = d3.extent(
            hateCrimeCount,
            (d) => d["Bias Motive Description"]
          );
          console.log(totalExtent);

          var y = d3.scaleLinear()
                    .domain([0, totalExtent[1]])
                    .range([chartHeight, 0]);
          let leftAxis = d3.axisLeft(y);
          let leftGridlines = d3.axisLeft(y)
                                .tickSize(-chartWidth - 10)
                                .tickFormat("");
          annotations.append("g")
                     .attr("class", "y axis")
                     .attr("transform","translate(" + (margin.left - 10) + "," + margin.top + ")")
                     .call(leftAxis);
          annotations.append("g")
                     .attr("class", "y gridlines")
                     .attr("transform","translate(" + (margin.left - 10) + "," + margin.top + ")")
                     .call(leftGridlines);

          var color = d3.scaleOrdinal(d3.schemeCategory10).domain(hateCrimeTypes);
          chartArea.append("g")
                   .selectAll("g")
            //appendthe correctbars
                   .data(stackedData)
                   .enter()
                   .append("g")
                   .attr("fill", function (d) { return color(d.key);})
                   .selectAll("rect")
                   .data(function (d) {return d;})
                   .enter()
                   .append("rect")
                   .attr("x", function (d) { return x(d.data.actor);})
                   .attr("y", function (d) { return y(d[1]);})
                   .attr("height", function (d) { return y(d[0]) - y(d[1]);})
                   .attr("width", x.bandwidth());
        }
        function getDomDemo(d) {
          n = demographics.filter((demo) => {
            return demo.boro_cd.includes(d.properties["boro_cd"]);
          });
          if (n.length === 0) {
            return null;
          }
          maxPop = 0
          domPop = null
          races.forEach(r => {
            if (n[0][r] > maxPop) {
              maxPop = n[0][r];
              domPop = r;
            }
          });
          return domPop;
        }
        //get top three values
        function getTopThree(d) {
          console.log(selectedPrecincts);
          console.log(demographics);
          n = demographics.filter((demo) => {
            return demo.boro_cd.includes(
              (d.properties["boro_cd"] = selectedPrecincts)
            );
          });
          if (n.length === 0) {
            return null;
          }
          // console.log(d);
          // console.log(n);
          pop1 = 0;
          pop2 = 0;
          pop3 = 0;
          firstpop = null;
          secondpop = null;
          thirdpop = null;

          topThree = [];
          races.forEach((r) => {
            if (n[0][r] > pop1) {
              pop3 = pop2;
              pop2 = pop1;
              pop1 = n[0][r];
              firstpop = r;
            } else if (n[0][r] > pop2) {
              pop3 = pop2;
              pop2 = n[0][r];
              secondpop = r;
            } else if (n[0][r] > pop3) {
              pop3 = n[0][r];
              thirdpop = r;
            }
          });
          topThree.push(pop1);
          topThree.push(pop2);
          topThree.push(pop3);
          return topThree;
        }

        updatePrecincts();
      };

      requestData();

      // MODIFIED CODE FROM 3/22 LECTURE TO DRAW LEGEND
      // Function needs a d3 selected SVG canvas where it will draw the legend and a source color scale
      function drawLegend(legend, legendColorScale) {

        // Bonus code here to draw an adaptive gradient legend so we can see different color scales for choropleth maps
        //  Credit Prof. Rz if you are basing a legend on this structure, and note SERIOUS PERFORMANCE CONSIDERATIONS

        //const legend = d3.select("#colorLegend");
        const legendWidth = legend.attr("width");
        const legendHeight = legend.attr("height");
        const legendMinMax = d3.extent(legendColorScale.domain()); // way to recover the minMax from most kinds of scales
        const barHeight = 60;
        const stepSize = 4; // warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance
        // Extend the minmax by 1 in either direction to expose more features
        const pixelScale = d3.scaleLinear().domain([0,legendWidth-40]).range([legendMinMax[0]-1,legendMinMax[1]+1]); // In this case the "data" are pixels, and we get numbers to use in colorScale
        const barScale = d3.scaleLinear().domain([legendMinMax[0]-1,legendMinMax[1]+1]).range([0,legendWidth-40]);
        const barAxis = d3.axisBottom(barScale);
        // Check if we're using a quantile scale - if so, we can do better
        if (legendColorScale.hasOwnProperty('quantiles')) {
          // Use the quantile breakpoints plus the min and max of the scale as tick values
          barAxis.tickValues(legendColorScale.quantiles().concat( legendMinMax ));
        }
        legend.select(".colorbar, .axis")
          .attr("transform","translate("+(20)+","+(barHeight+5)+")")
          .call(barAxis)
          // .call(barAxis);

        // Draw rects of color down the bar
        let bar = legend.append("g").attr("transform","translate("+(20)+","+(0)+")")
        for (let i=0; i<legendWidth-40; i=i+stepSize) {
          bar.append("rect")
            .attr("x", i)
            .attr("y", 0)
            .attr("width", stepSize)
            .attr("height",barHeight)
            .style("fill", legendColorScale( pixelScale(i) )); // pixels => countData => color
        }
        // Put lines in to mark actual min and max of our data
        bar.append("line").attr("stroke","white").attr("stroke-width",3).attr("x1", barScale(legendMinMax[0])).attr("x2", barScale(legendMinMax[0])).attr("y1", 0).attr("y1", barHeight+4);
        bar.append("line").attr("stroke","white").attr("stroke-width",3).attr("x1", barScale(legendMinMax[1])).attr("x2", barScale(legendMinMax[1])).attr("y1", 0).attr("y1", barHeight+4);

      }

      //function to update the legend
      function updateLegend(legend, legendColorScale) {
        const barAxis = d3.axisBottom(barScale);
        // Check if we're using a quantile scale - if so, we can do better
        if (legendColorScale.hasOwnProperty('quantiles')) {
          // Use the quantile breakpoints plus the min and max of the scale as tick values
          barAxis.tickValues(legendColorScale.quantiles().concat( legendMinMax ));
        }
        legend.select(".colorbar, .axis").call(barAxis)
      }

    </script>
  </body>
</html>
