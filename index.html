<!DOCTYPE html>
<html>
  <head>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Domine&display=swap');
      body{
        margin: auto;
        width: 95vw;
        font-family: 'Domine', serif;
        color: 	#0b405a;
      }
      strong{
        background: #ffc63d;
      }
      rect.selection{
        fill: #ffc63d
      }
      .area {
        stroke: #d05228;
        fill: white;
        stroke-width: 2px;
      }

      #sidebar {
        border-top:2px solid #d05228	;
        border-right: 2px solid #d05228	;
        background: #ffcebf;
        display: flex;
        flex-direction: column;
        text-align: left;
        width: 225px;
      }
      #sidebar h4{
        margin-top: 20px;
      }
      #control{
        background-color: #ffcebf;
      }
      #details{
        padding: 20px;
      }
      #detailscss{
        text-align: left;
        padding: 20px;
      }
      .detailscolor{
        border-top:#d05228 2px solid;

        background-color: #ffcebf;

        border-bottom: 2px solid #d05228	;
        padding: 20px 20px 0px 20px;
      }
      .detailscolor p{
        margin-top:2px;
        margin-bottom: 8px;
      }
      .detailscolor h4{
        margin-bottom: 0px;
      }
      .row {
        display: flex;
        flex-direction: row;
      }
      h4{
        margin-top: 0px;
        margin-bottom: 10px;
      }
      #filters {
        display: block;
        text-align: center;
      }

      button {
        padding: 5px;
        margin: 10px;
        display: block;
        border: #d05228 solid 2px;
        color:#d05228;
        background-color: white;
      }
      button#clear:hover{
        background-color: #ffc63d

      }
      button:hover{
        background-color: #ffc63d

      }
      #directions {
        display: flex;
        flex-direction: column;
        margin: auto;
      }

      #header{
        padding: 10px;
      }
      #legend {
        display: block;
        width: 100px;
      }

      #colorlegend {
        position: absolute;
        top: 970px;
        left: 500px;
      }

      #overlay {
        position: relative;
        bottom: 200px;
        left: 30px;
        width: 100px;
      }

      .col {
        display: flex;
        flex-direction: column;
      }
      .gridlines line {
        stroke: #bbb;
      }

      .gridlines .domain {
        stroke: none;
      }
    </style>
  </head>

  <body>
    <div id="directions">
      <div id="header">
    <h1>Hate Crimes in NYC</h1>
    <p>By: Gracie Jing (kgj7), Connie Liu (cl2264), Olivia Zhu (oz28)</p>
    <p>Directions: Filter and visualize data by changing the time parameters or race-based hatecrime filters, selecting a specific police precinct, or adding a demographic overlay.</p>
    <p>This visualization was designed to help users identify the frequency of hate
      crimes across New York City. We want to focus on racially-based hate crimes, so
      the user can choose to filter by a specific type of anti-race hate crime. To
      visualize change across time, the user may also select specific ranges of time
      to examine and see if there are spikes due to current or past events. To see demographic data, the user can choose to show
      the demographic overlay, which will show the main demographic of each area. When
      a filter is selected this will only indicate the areas of that selected demographic.
      Since the demographic overlay still shows the choropleth map of frequency of
      hate crimes in each precinct, the user can see if areas with one race as the main demographic is the area
      where most of the hate crimes of that demographic are happening.
  </div>
    <div class="row">
      <div id="sidebar" class="detailscolor">
        <div id="clearArea"></div>
        <h4><strong>Filter</strong> Hate Crime by Race</h4>
        <div id="filters"></div>
        <div id="legend"></div>
        <h4><strong>Overlay</strong> with Main Demographic per Community District</h4>
        <svg id="demolegend"></svg>
        <button id="demographic">Show Demographic Overlay</button>
      </div>
      <div class="col">
        <div class = "detailscolor">
        <h4><strong>Time Scrubber</strong> & Number of Hate Crimes Related to Race Filters Over Time        </h4>

          <p>Narrow the dataset according to time ranges as well with the line graph</p>
        <div id="control"></div>
      </div>
        <div class="row">
          <div class="col">
            <div id="detailscss">
          <h4><strong>Click</strong> on Precinct to Filter & Frequency of Hate Crimes Per Police Precinct</h4>
          <svg id="map" width="475" height="475"></svg>
        </div>
        </div>
          <div class="col">
            <div id="details">
              <h4>Details - Number of hate crimes per added filter:</h4>
              <div id="precinct">No selected precinct</div>
              <div id="total"></div>
              <div id="typeTotal"></div>
              <div id="timeTotal"></div>
              <div id="allTotal"></div>
            </div>
            <div id ="detailscss">
            <h4>Number of Hate Crimes Reported per Category related to Precincts and Time Filters</h4>
            <svg id="bar" width="400" height="350"></svg>
          </div>
          </div>

        </div>

      </div>
      <div id="colorlegend">
        <svg
          id="colorLegend"
          height="70"
          width="300"
          style="background: #fff; margin-left: 30px"
        ></svg>
      </div>
    </div>

    <div id="overlay"></div>
    <script>
      //create choropleth
      const svg = d3.select("svg#map");
      const width = svg.attr("width");
      const height = svg.attr("height");
      const margin = { top: 20, right: 20, bottom: 20, left: 20 }
      const mapWidth = width - margin.left - margin.right;
      const mapHeight = height - margin.top - margin.bottom;
      const map = svg.append("g")
      .attr("transform","translate("+margin.left+","+margin.top+")");

      //demographic map
      const demoMap = svg.append("g")
      .attr("transform","translate("+margin.left+","+margin.top+")");

      const outlines = svg.append("g")
      .attr("transform","translate("+margin.left+","+margin.top+")");

      const requestData = async function () {
        // a CSV dataset of NYPD hate crimes
        let hateCrimes = await d3.csv("NYPD_Hate_Crimes2.csv", d3.autoType);

        // a GeoJSON dataset of police precincts in NYC
        let precincts = await d3.json("Police_Precincts.geojson");

        // a GeoJSON data set of community districts in NYC
        let communities = await d3.json("Community Districts.geojson");

        // a CSV dataset of demographics of NYC
        let demographics = await d3.csv("demo_2018_acs5yr_puma.csv");

        const boroughToNum = {
          Queens: "4",
          Bronx: "2",
          Manhattan: "1",
          Brooklyn: "3",
          "Staten Island": "5",
        };

        // clean up hate crime data
        // create d3 time objects
        let timeParser = d3.timeParse("%m/%d/%Y");

        let min_date = timeParser(hateCrimes[0]["Record Create Date"]);
        let max_date = min_date;

        hateCrimes.forEach((d) => {
          d["Arrest Date"] = timeParser(d["Arrest Date"]);
          d["Record Create Date"] = timeParser(d["Record Create Date"]);

          // find the min and max date for the time slider
          if (d["Record Create Date"] < min_date) {
            min_date = d["Record Create Date"];
          } else if (d["Record Create Date"] > max_date) {
            max_date = d["Record Create Date"];
          }
          d["precinct"] = d["Complaint Precinct Code"];
        });

        // clean up demographic data
        demographics.pop();
        demographics.forEach((d) => {
          d.asian = Number(d["AsnNHE"].replace(/,/g, ""));
          d.hispanic = Number(d["Hsp1E"].replace(/,/g, ""));
          d.white = Number(d["WtNHE"].replace(/,/g, ""));
          d.native = Number(d["AIANNHE"].replace(/,/g, ""));
          d.black = Number(d["BlNHE"].replace(/,/g, ""));
          d.other =
            Number(d["OthNHE"].replace(/,/g, "")) +
            Number(d["NHPINHE"].replace(/,/g, ""));
          d.twoplus = Number(d["Rc2plNHE"].replace(/,/g, ""));
          d.boro_cd = getCDNum(d["GeogName"], d["Borough"]); 
        });

        let colorScale = d3.scaleQuantile();

        //create map for precincts
        var precinctProjection = d3
          .geoMercator()
          .fitSize([mapWidth, mapHeight], precincts);
        var precinctPath = d3.geoPath().projection(precinctProjection);
        map
          .selectAll("path.precinct")
          .data(precincts.features)
          .join("path")
          .attr("class", (d) => `precinct p${d.properties.precinct}`)
          .attr("d", precinctPath);

        //outline
        outlines
          .selectAll("path.outline")
          .data(precincts.features)
          .join("path")
          .attr("class", (d) => `precinct outline p${d.properties.precinct}`)
          .attr("fill-opacity", 0)
          .attr("stroke", "black")
          .attr("stroke-width", 1)
          .attr("d", precinctPath)
          .on("click", updateSelected);

        let races = [
          "asian",
          "black",
          "white",
          "hispanic",
          "other",
          "twoplus",
          null,
        ];

        let demoScale = d3
          .scaleOrdinal()
          .domain(races)
          .range(d3.schemeCategory10);

        var demoProjection = d3
          .geoMercator()
          .fitSize([mapWidth, mapHeight], communities);
        var demoPath = d3.geoPath().projection(demoProjection);
        demoMap
          .selectAll("path.community")
          .data(communities.features)
          .join("path")
          .attr("class", "community")
          .attr("stroke-width", 0)
          .attr("fill", (d) => {
            if (getDomDemo(d) == null) {
              return "gray";
            }
            else {
              return demoScale(getDomDemo(d));
            }
          })
          .attr("d", demoPath)
          .attr("opacity", 0.5)
          .attr("visibility", "hidden");

        //create button to show demographic overlay
        let showDemoButton = d3.select("button#demographic");
        showDemoButton.attr("clicked", false).on("click", showDemographics);

        //create filters for hate crime types
        const hateCrimeTypes = [
          "ANTI-ASIAN",
          "ANTI-BLACK",
          "ANTI-WHITE",
          "ANTI-HISPANIC",
          "ANTI-OTHER ETHNICITY",
          "ANTI-MULTI-RACIAL GROUPS",
        ];

        const demoToCrime = {
          asian: "ANTI-ASIAN",
          black: "ANTI-BLACK",
          white: "ANTI-WHITE",
          hispanic: "ANTI-HISPANIC",
          other: "ANTI-OTHER ETHNICITY",
          twoplus: "ANTI-MULTI-RACIAL GROUPS",
        };

        const crimeToDemo = {};
        for (let key in demoToCrime) {
          crimeToDemo[demoToCrime[key]] = key;
        }

        // create filters
        let filters = d3.select("#filters");
        let crimeFilter = filters
          .append("div")
          .attr("id", "type")
          .attr("class", "filter");

        clearArea = d3.select("#clearArea")
        let clearButton = clearArea
          .append("button")
          .attr("id", "clear")
          .text("Reset Visualizations")
          .on("click", clear);

        hateCrimeTypes.forEach((d) => {
          crimeFilter
            .append("button")
            .attr("name", d)
            .attr("id", d)
            .attr("class", "type")
            .attr("param", "Bias Motive Description")
            .attr("clicked", false)
            .text(d)
            .on("click", filterClick);
        });

        let filteredType = null;
        let filteredHateCrimes = hateCrimes;
        let selectedPrecinct = null;
        let selectedHateCrimes = hateCrimes;

        //create time slider
        let timeSliderHeight = 70;
        let timeSliderWidth = 800;
        let axisLeftMargin = 25;

        // integer of time scale range
        var time_start = min_date;
        var time_end = max_date;

        // date object of time scale range
        var display_time_start = time_start;
        var display_time_end = time_end;

        // code to make time scrubber
        function makePath() {
          let values = hateCrimes;
          if (filteredType !== null) {
            values = hateCrimes.filter(
              (d) =>
                d["Bias Motive Description"] === filteredType
            );
          }

          values = values.map(d => d["Record Create Date"]);

          let numBins = 30;
          let histoGen = d3
            .histogram()
            .domain([min_date, max_date])
            .thresholds(numBins);

          let counts = histoGen(values);

          let time_spacing = counts[1].x1 - counts[1].x0;

          counts[0].x0 = counts[0].x1 - time_spacing;
          counts[counts.length - 1].x1 =
            counts[counts.length - 1].x0 + time_spacing;

          counts.unshift({
            x0: 0,
            x1: counts[0].x0,
            length: counts[0].length,

          });

          // y scale
          let yExtent = d3.extent(counts, (d) => d.length);
          let freqScale = d3
            .scaleLinear()
            .domain(yExtent)
            .range([timeSliderHeight, 4]);
          let yAxis = d3.axisLeft(freqScale).ticks(5);

          canvas.select(".y-axis").remove();

          canvas
            .append("g")
            .attr("transform", `translate(${axisLeftMargin}, 0)`)
            .attr("class", "y-axis")
            .call(yAxis);

          let area = d3
            .area()
            .x((d) => xScale(d.x1) + 10)
            .y0(freqScale(0))
            .y1((d) => freqScale(d.length))

          canvas.select(".areaLayer").remove();

          areaLayer = canvas.append("g").attr("class", "areaLayer");

          areaLayer
            .append("path")
            .datum(counts)
            .attr("transform", `translate(${axisLeftMargin}, -${yExtent[0]})`)
            .attr("class", "area")
            .attr("d", area);

            areaLayer.lower();
          if (filteredType === null) {
            d3.selectAll(".area").style("fill", "white");
          }
          else {
            d3.selectAll(".area").style("fill", demoScale(crimeToDemo[filteredType]));
          }
        }

        let formatTimeMonth = d3.timeFormat("%B %Y");
        let formatTimeDate = d3.timeFormat("%B %d %Y");

        let xScale = d3
          .scaleLinear()
          .domain([min_date, max_date])
          .range([10, timeSliderWidth - 10]);
        let xAxis = d3.axisBottom(xScale).tickFormat(formatTimeMonth);

        let wrapper = d3.select("#control");
        let canvas = wrapper
          .append("svg")
          .attr("width", timeSliderWidth + 50)
          .attr("height", timeSliderHeight + 50);

        let areaLayer = canvas.append("g").attr("class", "areaLayer");
        canvas
          .append("g")
          .attr(
            "transform",
            `translate(${axisLeftMargin}, ${timeSliderHeight + 15})`
          )
          .attr("class", "x-axis")
          .call(xAxis);

          let myBrush = d3
          .brushX()
          .extent([
            [10 + axisLeftMargin, 0],
            [timeSliderWidth + 20, timeSliderHeight],
          ])
          .on("brush end", brushMoved);

        makePath();

        function brushMoved(event) {

          if (event.selection !== null) {
            let startPixels = event.selection[0];
            let start = xScale.invert(startPixels);

            let endPixels = event.selection[1];
            let end = xScale.invert(endPixels);

            filterFunc = (d) =>
              d["Record Create Date"] >= start &&
              d["Record Create Date"] <= end;

            time_start = start;
            time_end = end;

            display_time_start = formatTimeDate(new Date(time_start));
            display_time_end = formatTimeDate(new Date(time_end));
          } else {
            filterFunc = (d) => true;
            time_start = min_date;
            time_end = max_date;
            display_time_start = formatTimeDate(time_start);
            display_time_end = formatTimeDate(time_end);
          }

          updateFiltered();
        }

        canvas.append("g").attr("class", "brush").call(myBrush);

        //demographic legend inspiration: https://bl.ocks.org/mtandre/bea54a387eb5506ad5d46cb5e74d9bce
        const legendarea = d3.select("svg#demolegend");

        let demoLegend = legendarea
          .append("g")
          .attr("class", "legend")
          .attr("transform", "translate(" + 10 + ", 10)");

        demoLegend
          .selectAll("rect")
          .data(races)
          .enter()
          .append("rect")
          .attr("x", 0)
          .attr("y", function (d, i) {
            return i * 18;
          })
          .attr("width", 12)
          .attr("height", 12)
          .attr("fill", function (d, i) {
            if (d == null) {
              return "gray";
            }
            else {
              return demoScale(d);
            }
          });

        demoLegend
          .selectAll("text")
          .data(races)
          .enter()
          .append("text")
          .text(function (d) {
            if (d === null) {
              return "no demographic data";
            } else {
              return d;
            }
          })
          .attr("x", 18)
          .attr("y", function (d, i) {
            return i * 18;
          })
          .attr("id", "label")
          .attr("text-anchor", "start")
          .attr("alignment-baseline", "hanging");

        let colorLegend = d3.select("#colorLegend");
        colorLegend.append("g").attr("class", "colorbar axis");

        //adding details for precinct on click
        let details = d3.select("#details").style("visibility", "hidden");

        // BEGINNING OF FUNCTIONS
        function getCDNum(s, boro) {
          i1 = s.indexOf("District") + 9;
          i2 = s.indexOf("--");
          cds = s.slice(i1, i2).split(" & ");
          cds.forEach((item, i) => {
            if (item.length < 2) {
              item = "0" + item;
            }
            cds[i] = boroughToNum[boro] + item;
          });

          return cds;
        }

        function updateSelected() {
          let precinct = d3.select(this);
          let precinctNumber = precinct.datum().properties["precinct"];

          // already selected
          if (selectedPrecinct === precinctNumber) {
            d3.selectAll(`.outline.p${precinctNumber}`).each(function () {
              d3.select(this).attr("stroke-width", 1);
            });
            selectedPrecinct = null;
          } else if (selectedPrecinct === null) {
            d3.selectAll(`.outline.p${precinctNumber}`).each(function () {
              d3.select(this).attr("stroke-width", 3)
            });
            selectedPrecinct = precinctNumber;
          } else {
            d3.selectAll(`.outline.p${selectedPrecinct}`).each(function () {
              d3.select(this).attr("stroke-width", 1);
            });
            d3.selectAll(`.outline.p${precinctNumber}`).each(function () {
              d3.select(this).attr("stroke-width", 3);
            });
            selectedPrecinct = precinctNumber;
          }

          updateDetails();
        }

        function updateDetails() {
          details.style("visibility", "")
          let txt = details.select("#precinct");
          let ttl = details.select("#total");
          let typeTtl = details.select("#typeTotal");
          let timeTtl = details.select("#timeTotal");
          let allTtl = details.select("#allTotal");

          if (selectedPrecinct === null) {
            selectedHateCrimes = hateCrimes;
            txt.text("No selected precinct");
            ttl.text(
              `Number of hate crimes: ${selectedHateCrimes.length}`
            );

            if (filteredType !== null) {
              typeTtl.text(
                `Number of ${filteredType.toLowerCase()} hate crimes: ${
                  hateCrimes.filter(d => d["Bias Motive Description"] == filteredType).length
                }`
              );
            } else {
              typeTtl.text("");
            }
            if (time_start != min_date || time_end != max_date) {
              timeTtl.text(
                `Number of hate crimes between ${display_time_start} and ${display_time_end}: ${
                  hateCrimes.filter(d => d["Record Create Date"] >= time_start &&
                  d["Record Create Date"] <= time_end).length
                }`);
            }
            else {
              timeTtl.text("");
            }
            if ((filteredType !== null) && (time_start != min_date || time_end != max_date)) {
              allTtl.text(
                `Number of ${filteredType.toLowerCase()} hate crimes between ${display_time_start} and ${display_time_end}: ${
                  hateCrimes.filter(d =>
                    d["Bias Motive Description"] == filteredType &&
                    d["Record Create Date"] >= time_start &&
                    d["Record Create Date"] <= time_end).length}`);
            }
            else {
              allTtl.text("");
            }
          } else {
            txt.text(`Selected Precinct: ${selectedPrecinct}`);
            selectedHateCrimes = hateCrimes.filter(
              (d) => d.precinct == selectedPrecinct
            );
            ttl.text(
              `Number of hate crimes in precinct ${selectedPrecinct}: ${selectedHateCrimes.length}`
            );
            selAndfil = hateCrimes.filter(
              (d) => d.precinct == selectedPrecinct && d["Bias Motive Description"] == filteredType
            );

            if (filteredType !== null) {
              typeTtl.text(
                `Number of ${filteredType.toLowerCase()} hate crimes: ${
                  hateCrimes.filter(d => d["Bias Motive Description"] == filteredType
                  && d.precinct == selectedPrecinct).length
                }`
              );
            } else {
              typeTtl.text("");
            }
            if (time_start != min_date || time_end != max_date) {
              timeTtl.text(
                `Number of hate crimes between ${display_time_start} and ${display_time_end}: ${
                  hateCrimes.filter(d => d["Record Create Date"] >= time_start &&
                  d["Record Create Date"] <= time_end &&
                  d.precinct == selectedPrecinct).length
                }`);
            }
            else {
              timeTtl.text("");
            }
            if ((filteredType !== null) && (time_start != min_date || time_end != max_date)) {
              allTtl.text(
                `Number of ${filteredType.toLowerCase()} hate crimes between ${display_time_start} and ${display_time_end}: ${
                  hateCrimes.filter(d =>
                    d["Bias Motive Description"] == filteredType &&
                    d["Record Create Date"] >= time_start &&
                    d["Record Create Date"] <= time_end &&
                    d.precinct == selectedPrecinct).length}`);
            }
            else {
              allTtl.text("");
            }
          }
          displayBar();
        }

        function showDemographics() {
          if (showDemoButton.attr("clicked") === "true") {
            showDemoButton.style("background-color", "white")
            showDemoButton.text("Show Demographic Overlay");
            demoMap.selectAll("path.community").attr("visibility", "hidden");
            showDemoButton.attr("clicked", false);
          } else {
            showDemoButton.style("background-color", "#ffc63d")
            showDemoButton.text("Remove Demographic Overlay");
            demoMap.selectAll("path.community").each(function (d) {
              if (filteredType === null) {
                d3.select(this).attr("visibility", "");
              } else if (demoToCrime[getDomDemo(d)] === filteredType) {
                d3.select(this).attr("visibility", "");
              }
            });
            showDemoButton.attr("clicked", true);
          }
        }

        function updateDemographics() {
          if (showDemoButton.attr("clicked") === "true") {
            demoMap.selectAll("path.community").each(function (d) {
              if (filteredType === null) {
                d3.select(this).attr("visibility", "");
              } else if (demoToCrime[getDomDemo(d)] === filteredType) {
                d3.select(this).attr("visibility", "");
              } else {
                d3.select(this).attr("visibility", "hidden");
              }
            });
          }
        }

        function clear() {

          d3.selectAll(".type")
            .each( function() {
              let fil = d3.select(this);
              fil.style("background-color", "white");
              fil.attr("clicked", false);
            });

          d3.selectAll(`.outline.p${selectedPrecinct}`).each(function () {
            d3.select(this).attr("stroke-width", "1");
          });

          details.style("visibility", "hidden");
          canvas.select("g.brush").call(myBrush.move, null);

          filteredHateCrimes = hateCrimes;
          selectedHateCrimes = hateCrimes;
          filteredType = null;
          selectedPrecinct = null;
          updateDemographics();
          updateDetails();
          updatePrecincts();
          makePath();
        }

        function filterClick() {
          let fil = d3.select(this);
          if (fil.attr("clicked") == "true") {
            filteredType = null;
            fil.style("background-color", "white");
            fil.attr("clicked", false)
          }
          else {
            filteredType = fil.attr("name");
            d3.selectAll(".type").each(function() {
              d3.select(this).style("background-color", "white");
              d3.select(this).attr("clicked", false);
            })
            fil.attr("clicked", true)
            fil.style("background-color", "#ffc63d");
          }

          updateFiltered();

          makePath();
        }

        //update precincts based on filtered data
        function updateFiltered() {

          if (filteredType !== null) {
            filteredHateCrimes = hateCrimes.filter(
              (d) =>
                d["Bias Motive Description"] === filteredType &&
                d["Record Create Date"] >= time_start &&
                d["Record Create Date"] <= time_end
            );
          } else {
            filteredHateCrimes = hateCrimes.filter(
              (d) =>
                d["Record Create Date"] >= time_start &&
                d["Record Create Date"] <= time_end
            );
          }

          updateDemographics();
          updateDetails();
          updatePrecincts();
        }

        function updatePrecincts() {
          //initialize hate crime frequency dictionary
          let precinctCrimeCount = {};

          precincts.features.forEach((d) => {
            precinctCrimeCount[d.properties.precinct] = 0;
          });

          filteredHateCrimes.forEach((d) => {
            precinctCrimeCount[d.precinct] += 1;
          });

          //update color scale
          colorScale
            .domain(Object.values(precinctCrimeCount))
            .range(d3.schemeGreys[5]);

          //color precincts
          map.selectAll(".precinct").style("fill", (d) => {
            count = precinctCrimeCount[d.properties.precinct];
            if (count === 0) {
              return colorScale.range()[0];
            } else {
              return colorScale(count);
            }
          });

          //update legend
          drawLegend(colorLegend, colorScale);
        }

        // CREATE BAR CHART
        //Bar chart inspired by lecture 
        const barChart = d3.select("svg#bar");
        const barMargin = { top: 10, right: 30, bottom: 90, left: 70 };
        const barWidth = barChart.attr("width");
        const barHeight = barChart.attr("height");
        const barChartWidth = barWidth - barMargin.left - barMargin.right;
        const barChartHeight = barHeight - barMargin.top - barMargin.bottom;

        let annotations = barChart.append("g").attr("id", "annotations1");
        let chartArea = barChart
          .append("g")
          .attr("id", "points")
          .attr(
            "transform",
            "translate(" + barMargin.left + "," + barMargin.top + ")"
          );

        var crimeScale = d3
          .scaleBand()
          .domain(hateCrimeTypes)
          .range([0, barChartWidth])
          .padding([0.2]);

        let bottomAxis = d3.axisBottom(crimeScale);

        annotations
          .append("g")
          .attr("class", "x axis")
          .attr(
            "transform",
            `translate(${barMargin.left},${
              barChartHeight + barMargin.top + 10
            })`
          )
          .call(bottomAxis);

        let leftAxis = d3.axisLeft();
        let leftGridlines = d3
          .axisLeft()
          .tickSize(-barChartWidth - 10)
          .tickFormat("");
        let leftAxisG = annotations
          .append("g")
          .attr("class", "y axis")
          .attr(
            "transform",
            `translate(${barMargin.left - 10},${barMargin.top})`
          );
        let leftGridlinesG = annotations
          .append("g")
          .attr("class", "y gridlines")
          .attr(
            "transform",
            `translate(${barMargin.left - 10},${barMargin.top})`
          );

        barChart
          .selectAll("text")
          .style("text-anchor", "end")
          .attr("dx", "-.8em")
          .attr("dy", ".15em")
          .attr("transform", "rotate(-25)");

        function displayBar() {
          hateCrimeCount = {};

          hateCrimeTypes.forEach((r) => {
            hateCrimeCount[r] = { type: r, number: 0 };
          });

          selectedHateCrimes.filter(d => d["Record Create Date"] >= time_start &&
            d["Record Create Date"] <= time_end).forEach((d) => {
            if (hateCrimeTypes.includes(d["Bias Motive Description"])) {
              hateCrimeCount[d["Bias Motive Description"]]["number"] += 1;
            }
          });

          var hateCountList = Object.values(hateCrimeCount);
          var dictLength = Object.values(hateCrimeCount).length;
          const totalExtent = d3.extent(hateCountList, (d) => d["number"]);

          // y scale
          var countScale = d3
            .scaleLinear()
            .domain([0, totalExtent[1]])
            .range([barChartHeight, 0]);

          leftAxis.scale(countScale);
          leftAxisG.transition().call(leftAxis);
          leftGridlines.scale(countScale);
          leftGridlinesG.transition().call(leftGridlines);

          chartArea
            .selectAll("rect.bar")
            .data(hateCountList)
            .join("rect")
            .attr("class", "bar")
            .attr("fill", (d) => demoScale(crimeToDemo[d["type"]]))
            .attr("x", (d) => crimeScale(d["type"]))
            .attr("y", (d) => countScale(d["number"]))
            .attr("height", (d) => countScale(0) - countScale(d["number"]))
            .attr("width", crimeScale.bandwidth());
        }

        function getDomDemo(d) {
          n = demographics.filter((demo) => {
            return demo.boro_cd.includes(d.properties["boro_cd"]);
          });
          if (n.length === 0) {
            return null;
          }
          maxPop = 0;
          domPop = null;
          races.forEach((r) => {
            if (n[0][r] > maxPop) {
              maxPop = n[0][r];
              domPop = r;
            }
          });
          return domPop;
        }

        updatePrecincts();
        updateDetails();
        displayBar();
      };

      requestData();

      // MODIFIED CODE FROM 3/22 LECTURE TO DRAW LEGEND
      // Function needs a d3 selected SVG canvas where it will draw the legend and a source color scale
      function drawLegend(legend, legendColorScale) {
        // Bonus code here to draw an adaptive gradient legend so we can see different color scales for choropleth maps
        //  Credit Prof. Rz if you are basing a legend on this structure, and note SERIOUS PERFORMANCE CONSIDERATIONS

        const legendWidth = legend.attr("width");
        const legendHeight = legend.attr("height");
        const legendMinMax = d3.extent(legendColorScale.domain()); 
        const barHeight = 20;
        const stepSize = 4; 
        const pixelScale = d3
          .scaleLinear()
          .domain([0, legendWidth - 40])
          .range([legendMinMax[0] - 1, legendMinMax[1] + 1]);
        const barScale = d3
          .scaleLinear()
          .domain([legendMinMax[0] - 1, legendMinMax[1] + 1])
          .range([0, legendWidth - 40]);
        const barAxis = d3.axisBottom(barScale);
        if (legendColorScale.hasOwnProperty("quantiles")) {
          barAxis.tickValues(legendColorScale.quantiles().concat(legendMinMax));
        }
        legend
          .select(".colorbar, .axis")
          .attr("transform", "translate(" + 20 + "," + (barHeight + 5) + ")")
          .call(barAxis);

        let bar = legend
          .append("g")
          .attr("transform", "translate(" + 20 + "," + 0 + ")");
        for (let i = 0; i < legendWidth - 40; i = i + stepSize) {
          bar
            .append("rect")
            .attr("x", i)
            .attr("y", 0)
            .attr("width", stepSize)
            .attr("height", barHeight)
            .style("fill", legendColorScale(pixelScale(i))); 
        }
        bar
          .append("line")
          .attr("stroke", "white")
          .attr("stroke-width", 3)
          .attr("x1", barScale(legendMinMax[0]))
          .attr("x2", barScale(legendMinMax[0]))
          .attr("y1", 0)
          .attr("y1", barHeight + 4);
        bar
          .append("line")
          .attr("stroke", "white")
          .attr("stroke-width", 3)
          .attr("x1", barScale(legendMinMax[1]))
          .attr("x2", barScale(legendMinMax[1]))
          .attr("y1", 0)
          .attr("y1", barHeight + 4);
      }

      function updateLegend(legend, legendColorScale) {
        const barAxis = d3.axisBottom(barScale);
        if (legendColorScale.hasOwnProperty("quantiles")) {
          barAxis.tickValues(legendColorScale.quantiles().concat(legendMinMax));
        }
        legend.select(".colorbar, .axis").call(barAxis);
      }
    </script>
  </body>
</html>
