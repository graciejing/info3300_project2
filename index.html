<!DOCTYPE html>
<html>
  <head>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <style>
      .area {
        stroke: royalblue;
        fill: skyblue;
        stroke-width: 2px;
      }

      #sidebar {
        display: flex;
        flex-direction: column;
        text-align: center;
      }

      .row {
        display: flex;
        flex-direction: row;
      }

      #filters {
        display: block;
        text-align: center;
      }

      button {
        padding: 5px;
        margin: 10px;
        display: block;
      }

      .active {
        background-color: red;
      }

      #directions {
        width: 200px;
        margin: 30px;
      }

      #legend {
        display: block;
        width: 100px;
      }

      #colorlegend {
        position: absolute;
        top: 300px;
        left: 230px;
      }

      #overlay {
        position: relative;
        bottom: 200px;
        left: 30px;
        width: 100px;
      }

      .col {
        display: flex;
        flex-direction: column;
      }
      body {
        margin: 30px;
      }
      .gridlines line {
        stroke: #bbb;
      }

      .gridlines .domain {
        stroke: none;
      }
    </style>
  </head>

  <body>
    <div class="row">
      <h1>Hate Crimes in NYC</h1>
      <p>By: Gracie Jing (kgj7), Connie Liu (cl2264), Olivia Zhu (oz28)</p>
      <p id="directions">
        Directions: Filter data by changing the time parameters and race filters
      </p>
    </div>
    <div class="row">
      <div id="sidebar">
        <div id="filters"></div>
        <div id="legend"></div>
        <svg id="demolegend"></svg>
        <button id="demographic">Show Demographic Overlay</button>
      </div>
      <div class="col">
        <div id="control"></div>
        <div id="colorlegend">
          <svg
            id="colorLegend"
            height="70"
            width="300"
            style="background: #fff; margin-left: 30px"
          ></svg>
        </div>
        <div class="row">
          <svg id="map" width="550" height="550"></svg>
          <div class="col">
            <h4>Details:</h4>
            <div id="details">
              <div id="precinct">No selected precinct</div>
              <div id="total"></div>
              <div id="filteredTotal"></div>
            </div>
            <svg id="bar" width="500" height="400"></svg>
          </div>
        </div>
      </div>
    </div>

    <div id="overlay"></div>

    <!-- <svg id="linegraph" width="1000" height="800"></svg> -->

    <script>
      //create cloropleth
      const svg = d3.select("svg#map");
      const linegraph = d3.select("svg#linegraph");
      const width = svg.attr("width");
      const height = svg.attr("height");
      //precinct map
      const mapWidth = width;
      const mapHeight = height;
      const map = svg.append("g");

      //demographic map
      const demoMap = svg.append("g");

      const outlines = svg.append("g");

      const requestData = async function () {
        // a CSV dataset of NYPD hate crimes
        let hateCrimes = await d3.csv("NYPD_Hate_Crimes2.csv", d3.autoType);

        // a GeoJSON dataset of police precincts in NYC
        let precincts = await d3.json("Police_Precincts.geojson");
        // console.log(precincts)

        let communities = await d3.json("Community Districts.geojson");

        // a CSV dataset of demographics of NYC
        let demographics = await d3.csv("demo_2018_acs5yr_puma.csv");

        const boroughToNum = {
          Queens: "4",
          Bronx: "2",
          Manhattan: "1",
          Brooklyn: "3",
          "Staten Island": "5",
        };

        // clean up hate crime data
        // create d3 time objects
        let timeParser = d3.timeParse("%m/%d/%Y");

        let min_date = timeParser(hateCrimes[0]["Record Create Date"]);
        let max_date = min_date;

        hateCrimes.forEach((d) => {
          d["Arrest Date"] = timeParser(d["Arrest Date"]);
          d["Record Create Date"] = timeParser(d["Record Create Date"]);

          // find the min and max date for the time slider
          if (d["Record Create Date"] < min_date) {
            min_date = d["Record Create Date"];
          } else if (d["Record Create Date"] > max_date) {
            max_date = d["Record Create Date"];
          }
          d["precinct"] = d["Complaint Precinct Code"];
        });

        // clean up demographic data
        demographics.pop();
        demographics.forEach((d) => {
          d.asian = Number(d["AsnNHE"].replace(/,/g, ""));
          d.hispanic = Number(d["Hsp1E"].replace(/,/g, ""));
          d.white = Number(d["WtNHE"].replace(/,/g, ""));
          d.native = Number(d["AIANNHE"].replace(/,/g, ""));
          d.black = Number(d["BlNHE"].replace(/,/g, ""));
          // d.hawaiianpi =;
          d.other =
            Number(d["OthNHE"].replace(/,/g, "")) +
            Number(d["NHPINHE"].replace(/,/g, ""));
          d.twoplus = Number(d["Rc2plNHE"].replace(/,/g, ""));
          d.boro_cd = getCDNum(d["GeogName"], d["Borough"]); //PUMAtoBoroCD[d['GeogName'].replace(/; New York/, "").replace(/, New York/, "")]
        });

        console.log(hateCrimes);
        console.log(precincts);
        console.log(demographics);
        console.log(communities);

        let colorScale = d3.scaleQuantile();

        //create map for precincts
        var precinctProjection = d3
          .geoMercator()
          .fitSize([mapWidth, mapHeight], precincts);
        var precinctPath = d3.geoPath().projection(precinctProjection);
        map
          .selectAll("path.precinct")
          .data(precincts.features)
          .join("path")
          .attr("class", (d) => `precinct p${d.properties.precinct}`)
          .attr("d", precinctPath);

        //outline
        outlines
          .selectAll("path.outline")
          .data(precincts.features)
          .join("path")
          .attr("class", (d) => `precinct outline p${d.properties.precinct}`)
          .attr("fill-opacity", 0)
          .attr("stroke", "black")
          .attr("stroke-width", 1)
          .attr("d", precinctPath)
          .on("click", updateSelected);

        //create demographic overlay
        let races = [
          "asian",
          "black",
          "hispanic",
          "white",
          "native",
          // "hawaiianpi",
          "other",
          "twoplus",
          null,
        ];

        let demoScale = d3
          .scaleOrdinal()
          .domain(races)
          .range(d3.schemeCategory10);

        var demoProjection = d3
          .geoMercator()
          .fitSize([mapWidth, mapHeight], communities);
        var demoPath = d3.geoPath().projection(demoProjection);
        demoMap
          .selectAll("path.community")
          .data(communities.features)
          .join("path")
          .attr("class", "community")
          // .attr("stroke", "black")
          .attr("stroke-width", 0)
          .attr("d", demoPath)
          .attr("opacity", 0.5)
          .attr("fill", (d) => demoScale(getDomDemo(d)))
          .attr("visibility", "hidden");

        //create button to show demographic overlay
        let showDemoButton = d3.select("button#demographic");
        showDemoButton.attr("clicked", false).on("click", showDemographics);

        //create filters for hate crime types
        const hateCrimeTypes = [
          "ANTI-ASIAN",
          "ANTI-BLACK",
          "ANTI-WHITE",
          "ANTI-HISPANIC",
          "ANTI-OTHER ETHNICITY",
          "ANTI-MULTI-RACIAL GROUPS",
        ];

        const demoToCrime = {
          asian: "ANTI-ASIAN",
          black: "ANTI-BLACK",
          white: "ANTI-WHITE",
          hispanic: "ANTI-HISPANIC",
          other: "ANTI-OTHER ETHNICITY",
          twoplus: "ANTI-MULTI-RACIAL GROUPS",
        };

        const crimeToDemo = {};
        for (let key in demoToCrime) {
          crimeToDemo[demoToCrime[key]] = key;
        }

        // create filters
        let filters = d3.select("#filters");
        let crimeFilter = filters
          .append("div")
          .attr("id", "type")
          .attr("class", "filter");

        // let updateButton = filters
        //   .append("button")
        //   .attr("id", "update")
        //   .text("Update")
        //   .on("click", updateFiltered);

        let clearButton = filters
          .append("button")
          .attr("id", "clear")
          .text("Clear")
          .on("click", clear);

        hateCrimeTypes.forEach((d) => {
          crimeFilter
            // .append("input")
            .append("button")
            .attr("name", d)
            .attr("id", d)
            // .attr("type", "checkbox")
            .attr("class", "type")
            .attr("param", "Bias Motive Description")
            .text(d)
            .on("click", filterClick);

          // crimeFilter.append("label").attr("for", d).text(d);
        });

        //create time slider

        let timeSliderHeight = 80;
        let timeSliderWidth = 900;

        let values = hateCrimes.map((d) => d["Record Create Date"]);

        let formatTime = d3.timeFormat("%B %d, %Y");

        let xScale = d3
          .scaleLinear()
          .domain([min_date, max_date])
          .range([10, timeSliderWidth - 10]);
        let xAxis = d3.axisBottom(xScale).tickFormat(formatTime);

        let wrapper = d3.select("#control");
        let canvas = wrapper
          .append("svg")
          .attr("width", timeSliderWidth)
          .attr("height", timeSliderHeight + 50);

        let areaLayer = canvas.append("g").attr("class", "areaLayer");
        canvas
          .append("g")
          .attr("transform", `translate(0, ${timeSliderHeight})`)
          .attr("class", "x-axis")
          .call(xAxis);

        let numBins = 30;
        let histoGen = d3
          .histogram()
          .domain([min_date, max_date])
          .thresholds(numBins);

        let counts = histoGen(values);

        let time_spacing = counts[1].x1 - counts[1].x0;

        counts[0].x0 = counts[0].x1 - time_spacing;
        counts[counts.length - 1].x1 =
          counts[counts.length - 1].x0 + time_spacing;

        counts.unshift({
          x0: 0,
          x1: counts[0].x0,
          length: counts[0].length,
        });

        console.log("counts");
        console.log(counts);

        // y scale
        let freqScale = d3
          .scaleLinear()
          .domain(d3.extent(counts, (d) => d.length))
          .range([timeSliderHeight, 4]);
        let yAxis = d3.axisLeft(freqScale);

        canvas.append("g").attr("class", "yAxis");
        canvas
          .append("g")
          .attr("transform", `translate(-10, 0)`)
          .attr("class", "y-axis")
          .call(yAxis);

        let area = d3
          .area()
          .x((d) => xScale(d.x1))
          .y0(freqScale(0))
          .y1((d) => freqScale(d.length))
          .curve(d3.curveNatural);

        areaLayer
          .append("path")
          .datum(counts)
          // .attr("transform", `translate(0, -50)`)
          .attr("class", "area")
          .attr("d", area);

        let brush = d3
          .brushX()
          .extent([
            [10, 0],
            [timeSliderWidth - 10, timeSliderHeight],
          ])
          .on("brush end", brushMoved);

        let filterFunc = (d) => true;
        var time_start = min_date;
        var time_end = max_date;
        function brushMoved(event) {
          // console.log(event.type, event.selection, event);

          if (event.selection !== null) {
            let startPixels = event.selection[0];
            let start = xScale.invert(startPixels);

            let endPixels = event.selection[1];
            let end = xScale.invert(endPixels);

            filterFunc = (d) =>
              d["Record Create Date"] >= start &&
              d["Record Create Date"] <= end;

            time_start = start;
            time_end = end;
            console.log("subset time");
            console.log(time_start);
            console.log(time_end);
          } else {
            filterFunc = (d) => true;
            time_start = min_date;
            time_end = max_date;
          }
          console.log("update hate crime data");
          updateHateCrimeData(filterFunc, hateCrimes);

          console.log("scaled time in brush moved");
          console.log(time_start);
          console.log(time_end);
          updateFiltered();
        }

        function updateHateCrimeData(filterFunc, hateCrimes) {
          let filteredHateCrimes = hateCrimes.filter((d) => filterFunc(d));

          console.log(filteredHateCrimes);
          return filteredHateCrimes;
        }

        canvas.append("g").attr("class", "brush").call(brush);

        //creating legends
        const legendarea = d3.select("svg#demolegend");

        let demoLegend = legendarea
          .append("g")
          .attr("class", "legend")
          .attr("transform", "translate(" + 10 + ", 10)");

        demoLegend
          .selectAll("rect")
          .data(races)
          .enter()
          .append("rect")
          .attr("x", 0)
          .attr("y", function (d, i) {
            return i * 18;
          })
          .attr("width", 12)
          .attr("height", 12)
          .attr("fill", function (d, i) {
            return demoScale(d);
          });

        demoLegend
          .selectAll("text")
          .data(races)
          .enter()
          .append("text")
          .text(function (d) {
            if (d === null) {
              return "no demographic data";
            } else {
              return d;
            }
          })
          .attr("x", 18)
          .attr("y", function (d, i) {
            return i * 18;
          })
          .attr("id", "label")
          .attr("text-anchor", "start")
          .attr("alignment-baseline", "hanging");

        let colorLegend = d3.select("#colorLegend");
        colorLegend.append("g").attr("class", "colorbar axis");
        // drawLegend(colorLegend, colorScale)

        //adding details for precinct on click
        let details = d3.select("#details");
        details
          .select("#total")
          .text(`Total number of hate crimes: ${hateCrimes.length}`);
        // details
        //   .append("div")
        //   .attr("id", "precinct")
        //   .attr("x", 0)
        //   .attr("y", 0)
        //   .attr("fill", "black")
        //   .text();

        // details
        //   .append("div")
        //   .attr("id", "total")
        //   .attr("x", 0)
        //   .attr("y", 0)
        //   .attr("fill", "black")
        //   .text("");

        let filteredType = null;
        let filteredHateCrimes = hateCrimes;
        let selectedPrecinct = null;
        let selectedHateCrimes = hateCrimes;

        // BEGINNING OF FUNCTIONS

        function getCDNum(s, boro) {
          i1 = s.indexOf("District") + 9;
          i2 = s.indexOf("--");
          cds = s.slice(i1, i2).split(" & ");
          cds.forEach((item, i) => {
            if (item.length < 2) {
              item = "0" + item;
            }
            cds[i] = boroughToNum[boro] + item;
          });

          return cds;
        }

        function updateSelected() {
          let precinct = d3.select(this);
          let precinctNumber = precinct.datum().properties["precinct"];

          let txt = d3.select("text#precinct");

          // already selected
          if (selectedPrecinct === precinctNumber) {
            d3.selectAll(`.outline.p${precinctNumber}`).each(function () {
              d3.select(this).attr("stroke-width", 1);
            });
            // selectedPrecincts = selectedPrecincts.filter(
            //   (d) => d !== precinctNumber
            // );
            selectedPrecinct = null;
            // if (selectedPrecincts === []) {
            txt.text("No selected precinct");
            // } else {
            // txt.text(`Selected Precincts: ${selectedPrecincts}`);
          } else if (selectedPrecinct === null) {
            d3.selectAll(`.outline.p${precinctNumber}`).each(function () {
              d3.select(this).attr("stroke-width", 3);
            });

            selectedPrecinct = precinctNumber;
            txt.text(`Selected Precinct: ${selectedPrecinct}`);
          } else {
            d3.selectAll(`.outline.p${selectedPrecinct}`).each(function () {
              d3.select(this).attr("stroke-width", 1);
            });

            d3.selectAll(`.outline.p${precinctNumber}`).each(function () {
              d3.select(this).attr("stroke-width", 3);
            });

            // selectedPrecincts.push(precinctNumber);
            selectedPrecinct = precinctNumber;
            txt.text(`Selected Precinct: ${selectedPrecinct}`);
          }

          updateDetails();
        }

        function updateDetails() {
          let txt = details.select("#precinct");
          let ttl = details.select("#total");
          let filteredTtl = details.select("#filteredTotal");
          if (selectedPrecinct === null) {
            selectedHateCrimes = hateCrimes;
            txt.text("No selected precinct");
            ttl.text(
              `Total number of hate crimes: ${selectedHateCrimes.length}`
            );
            if (filteredType !== null) {
              filteredTtl.text(
                `Total number of ${filteredType.toLowerCase()} hate crimes: ${
                  filteredHateCrimes.length
                }`
              );
            } else {
              filteredTtl.text("");
            }
          } else {
            selectedHateCrimes = hateCrimes.filter(
              (d) => d.precinct == selectedPrecinct
            );
            ttl.text(
              `Total number of hate crimes: ${selectedHateCrimes.length}`
            );
            selAndfil = filteredHateCrimes.filter(
              (d) => d.precinct == selectedPrecinct
            );
            if (filteredType !== null) {
              filteredTtl.text(
                `Total number of ${filteredType.toLowerCase()} hate crimes: ${
                  selAndfil.length
                }`
              );
            } else {
              filteredTtl.text("");
            }
          }

          displayBar();
        }

        function showDemographics() {
          if (showDemoButton.attr("clicked") === "true") {
            showDemoButton.text("Show Demographic Overlay");
            demoMap.selectAll("path.community").attr("visibility", "hidden");
            showDemoButton.attr("clicked", false);
          } else {
            showDemoButton.text("Remove Demographic Overlay");
            demoMap.selectAll("path.community").each(function (d) {
              if (filteredType === null) {
                d3.select(this).attr("visibility", "");
              } else if (demoToCrime[getDomDemo(d)] === filteredType) {
                d3.select(this).attr("visibility", "");
              }
            });

            showDemoButton.attr("clicked", true);
          }
        }

        function updateDemographics() {
          if (showDemoButton.attr("clicked") === "true") {
            console.log("updating");
            console.log(filteredType);
            demoMap.selectAll("path.community").each(function (d) {
              if (filteredType === null) {
                d3.select(this).attr("visibility", "");
              } else if (demoToCrime[getDomDemo(d)] === filteredType) {
                d3.select(this).attr("visibility", "");
              } else {
                d3.select(this).attr("visibility", "hidden");
              }
            });
          }
        }

        function clear() {
          d3.selectAll(`.outline.p${selectedPrecinct}`).each(function () {
            d3.select(this).attr("stroke-width", "1");
          });

          d3.selectAll(".type")
            .each( function() {
              let fil = d3.select(this);
              fil.style("background-color", "");
            });

          filteredHateCrimes = hateCrimes;
          selectedHateCrimes = hateCrimes;
          filteredType = null;
          selectedPrecinct = null;
          updateDemographics();
          updateDetails();
          updatePrecincts();
        }

        function filterClick() {
          let fil = d3.select(this);
          filteredType = fil.attr("name");
          console.log(filteredType);

          console.log("filter click");
          updateFiltered();
        }
        // function removeActive(filteredtype) {
        //   let activeButton = document.getElementsByClassName("active");
        //   let activeType = document.getElementById(filteredtype);
        //   if (activeButton != activeType) {
        //     activeButton.classList.remove("active");
        //   }
        // }
        //update precincts based on filtered data
        function updateFiltered() {
          console.log("scaled time in update filtered");
          console.log(time_start);
          console.log(time_end);
          // var element = document.getElementById(filteredType);
          // element.classList.add("active");

          d3.selectAll(".type")
            .each( function() {
            let fil = d3.select(this);
            if (fil.attr("name") == filteredType) {
              fil.style("background-color", "red");
            }
            else {
              fil.style("background-color", "");
            }
          });


          if (filteredType !== null) {
            filteredHateCrimes = hateCrimes.filter(
              (d) =>
                d["Bias Motive Description"] === filteredType &&
                d["Record Create Date"] >= time_start &&
                d["Record Create Date"] <= time_end
            );
          } else {
            filteredHateCrimes = hateCrimes.filter(
              (d) =>
                d["Record Create Date"] >= time_start &&
                d["Record Create Date"] <= time_end
            );
          }

          // let filterFunc = (d) =>
          //   d["Record Create Date"] >= time_start && d["Record Create Date"] <= time_end;
          // filteredHateCrimes = filteredHateCrimes.filter((d) =>
          //   d["Record Create Date"] >= time_start && d["Record Create Date"] <= time_end;);

          // return (d[key] === val);

          console.log("filtered hate crimes");
          console.log(filteredHateCrimes);
          updateDemographics();
          updateDetails();
          updatePrecincts();
        }

        function updatePrecincts() {
          //initialize hate crime frequency dictionary
          let precinctCrimeCount = {};

          // updateFiltered();
          precincts.features.forEach((d) => {
            precinctCrimeCount[d.properties.precinct] = 0;
          });
          //tabulates hatecrimes
          filteredHateCrimes.forEach((d) => {
            precinctCrimeCount[d.precinct] += 1;
          });

          //need to figure out colorScale
          //update color scale
          colorScale
            .domain(Object.values(precinctCrimeCount))
            .range(d3.schemeGreys[5]);

          //color precincts
          map.selectAll(".precinct").style("fill", (d) => {
            count = precinctCrimeCount[d.properties.precinct];
            if (count === 0) {
              return colorScale.range()[0];
            } else {
              return colorScale(count);
            }
          });

          //update legend
          drawLegend(colorLegend, colorScale);
          //put code updating here, assume dataset is filteredhatecrimes
          // displayBar();
        }

        //creates a new dataset of only stuff from that precinct
        //use filterdhatecrimes+ hatecrimetypes
        //white {type: white number: 20}, black {type: white number: 20}
        function wrap(text, width) {
          text.each(function () {
            var text = d3.select(this),
              words = text.text().split(/\s+/).reverse(),
              word,
              line = [],
              lineNumber = 0,
              lineHeight = 1.1, // ems
              y = text.attr("y"),
              dy = parseFloat(text.attr("dy")),
              tspan = text
                .text(null)
                .append("tspan")
                .attr("x", 0)
                .attr("y", y)
                .attr("dy", dy + "em");
            while ((word = words.pop())) {
              line.push(word);
              tspan.text(line.join(" "));
              if (tspan.node().getComputedTextLength() > width) {
                line.pop();
                tspan.text(line.join(" "));
                line = [word];
                tspan = text
                  .append("tspan")
                  .attr("x", 0)
                  .attr("y", y)
                  .attr("dy", ++lineNumber * lineHeight + dy + "em")
                  .text(word);
              }
            }
          });
        }

        // CREATE BAR CHART

        const barChart = d3.select("svg#bar");
        const barMargin = { top: 30, right: 30, bottom: 90, left: 70 };
        const barWidth = barChart.attr("width");
        const barHeight = barChart.attr("height");
        const barChartWidth = barWidth - barMargin.left - barMargin.right;
        const barChartHeight = barHeight - barMargin.top - barMargin.bottom;

        let annotations = barChart.append("g").attr("id", "annotations1");
        let chartArea = barChart
          .append("g")
          .attr("id", "points")
          .attr(
            "transform",
            "translate(" + barMargin.left + "," + barMargin.top + ")"
          );
        // .attr("transform", "rotate(90)");

        var crimeScale = d3
          .scaleBand()
          .domain(hateCrimeTypes)
          .range([0, barChartWidth])
          .padding([0.2]);

        let bottomAxis = d3.axisBottom(crimeScale);

        annotations
          .append("g")
          .attr("class", "x axis")
          .attr(
            "transform",
            `translate(${barMargin.left},${
              barChartHeight + barMargin.top + 10
            })`
          )
          .call(bottomAxis);

        let leftAxis = d3.axisLeft();
        let leftGridlines = d3
          .axisLeft()
          .tickSize(-barChartWidth - 10)
          .tickFormat("");
        let leftAxisG = annotations
          .append("g")
          .attr("class", "y axis")
          .attr(
            "transform",
            `translate(${barMargin.left - 10},${barMargin.top})`
          );
        let leftGridlinesG = annotations
          .append("g")
          .attr("class", "y gridlines")
          .attr(
            "transform",
            `translate(${barMargin.left - 10},${barMargin.top})`
          );

        // // bottom axis

        barChart
          .selectAll("text")
          .style("text-anchor", "end")
          .attr("dx", "-.8em")
          .attr("dy", ".15em")
          .attr("transform", "rotate(-25)");

        function displayBar() {
          hateCrimeCount = {};

          hateCrimeTypes.forEach((r) => {
            hateCrimeCount[r] = { type: r, number: 0 };
          });

          selectedHateCrimes.forEach((d) => {
            if (hateCrimeTypes.includes(d["Bias Motive Description"])) {
              hateCrimeCount[d["Bias Motive Description"]]["number"] += 1;
            }
          });

          var hateCountList = Object.values(hateCrimeCount);
          var dictLength = Object.values(hateCrimeCount).length;
          console.log(hateCountList);
          const totalExtent = d3.extent(hateCountList, (d) => d["number"]);

          // y scale
          var countScale = d3
            .scaleLinear()
            .domain([0, totalExtent[1]])
            .range([barChartHeight, 0]);

          leftAxis.scale(countScale);
          leftAxisG.transition().call(leftAxis);
          leftGridlines.scale(countScale);
          leftGridlinesG.transition().call(leftGridlines);
          // leftAxis = d3.axisLeft(countScale);
          // leftGridlines = d3
          //   .axisLeft(countScale)
          //   .tickSize(-barChartWidth - 10)
          //   .tickFormat("");
          // annotations.call(leftAxis);
          // annotations.call(leftGridlines);
          // var colorScale = d3
          //   .scaleOrdinal(d3.schemeCategory10)
          //   .domain(hateCrimeTypes);
          chartArea
            .selectAll("rect.bar")
            .data(hateCountList)
            .join("rect")
            .attr("class", "bar")
            .attr("fill", (d) => demoScale(crimeToDemo[d["type"]]))
            .attr("x", (d) => crimeScale(d["type"]))
            .attr("y", (d) => countScale(d["number"]))
            .attr("height", (d) => countScale(0) - countScale(d["number"]))
            .attr("width", crimeScale.bandwidth());
        }

        function getDomDemo(d) {
          n = demographics.filter((demo) => {
            return demo.boro_cd.includes(d.properties["boro_cd"]);
          });
          if (n.length === 0) {
            return null;
          }
          maxPop = 0;
          domPop = null;
          races.forEach((r) => {
            if (n[0][r] > maxPop) {
              maxPop = n[0][r];
              domPop = r;
            }
          });
          return domPop;
        }

        updatePrecincts();
        updateDetails();
      };

      requestData();

      // MODIFIED CODE FROM 3/22 LECTURE TO DRAW LEGEND
      // Function needs a d3 selected SVG canvas where it will draw the legend and a source color scale
      function drawLegend(legend, legendColorScale) {
        // Bonus code here to draw an adaptive gradient legend so we can see different color scales for choropleth maps
        //  Credit Prof. Rz if you are basing a legend on this structure, and note SERIOUS PERFORMANCE CONSIDERATIONS

        //const legend = d3.select("#colorLegend");
        const legendWidth = legend.attr("width");
        const legendHeight = legend.attr("height");
        const legendMinMax = d3.extent(legendColorScale.domain()); // way to recover the minMax from most kinds of scales
        const barHeight = 20;
        const stepSize = 4; // warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance
        // Extend the minmax by 1 in either direction to expose more features
        const pixelScale = d3
          .scaleLinear()
          .domain([0, legendWidth - 40])
          .range([legendMinMax[0] - 1, legendMinMax[1] + 1]); // In this case the "data" are pixels, and we get numbers to use in colorScale
        const barScale = d3
          .scaleLinear()
          .domain([legendMinMax[0] - 1, legendMinMax[1] + 1])
          .range([0, legendWidth - 40]);
        const barAxis = d3.axisBottom(barScale);
        // Check if we're using a quantile scale - if so, we can do better
        if (legendColorScale.hasOwnProperty("quantiles")) {
          // Use the quantile breakpoints plus the min and max of the scale as tick values
          barAxis.tickValues(legendColorScale.quantiles().concat(legendMinMax));
        }
        legend
          .select(".colorbar, .axis")
          .attr("transform", "translate(" + 20 + "," + (barHeight + 5) + ")")
          .call(barAxis);
        // .call(barAxis);

        // Draw rects of color down the bar
        let bar = legend
          .append("g")
          .attr("transform", "translate(" + 20 + "," + 0 + ")");
        for (let i = 0; i < legendWidth - 40; i = i + stepSize) {
          bar
            .append("rect")
            .attr("x", i)
            .attr("y", 0)
            .attr("width", stepSize)
            .attr("height", barHeight)
            .style("fill", legendColorScale(pixelScale(i))); // pixels => countData => color
        }
        // Put lines in to mark actual min and max of our data
        bar
          .append("line")
          .attr("stroke", "white")
          .attr("stroke-width", 3)
          .attr("x1", barScale(legendMinMax[0]))
          .attr("x2", barScale(legendMinMax[0]))
          .attr("y1", 0)
          .attr("y1", barHeight + 4);
        bar
          .append("line")
          .attr("stroke", "white")
          .attr("stroke-width", 3)
          .attr("x1", barScale(legendMinMax[1]))
          .attr("x2", barScale(legendMinMax[1]))
          .attr("y1", 0)
          .attr("y1", barHeight + 4);
      }

      //function to update the legend
      function updateLegend(legend, legendColorScale) {
        const barAxis = d3.axisBottom(barScale);
        // Check if we're using a quantile scale - if so, we can do better
        if (legendColorScale.hasOwnProperty("quantiles")) {
          // Use the quantile breakpoints plus the min and max of the scale as tick values
          barAxis.tickValues(legendColorScale.quantiles().concat(legendMinMax));
        }
        legend.select(".colorbar, .axis").call(barAxis);
      }
    </script>
  </body>
</html>
